{
    "docs": [
        {
            "location": "/",
            "text": ".bs-sidebar { display: none; }\n\n\n\nBundleWrap documentation\n\n\nCheck out the \nquickstart tutorial\n to get started.\n\n\nIf you run into a problem that is not answered in these docs, please\nfind us on \nIRC\n or \nTwitter\n. We\u2019re happy to help!\n\n\n\n\nIs BundleWrap the right tool for you?\n\n\nWe think you will enjoy BundleWrap a lot if you:\n\n\n\n\nknow some Python\n\n\nlike to write your configuration from scratch and control every bit\n    of it\n\n\nhave lots of unique nodes\n\n\nare trying to get a lot of existing systems under management\n\n\nare NOT trying to handle a massive amount of nodes (let\u2019s say more\n    than 1000)\n\n\nlike to start small\n\n\ndon\u2019t want yet more stuff to run on your nodes (or mess with\n    appliances as little as possible)\n\n\nprefer a simple tool to a fancy one\n\n\nwant as much as possible in git/hg/bzr\n\n\nhave strongly segmented internal networks\n\n\n\n\nYou might be better served with a different config management system if\nyou:\n\n\n\n\nare already using a config management system and don\u2019t have any\n    major issues\n\n\nhate Python and/or JSON\n\n\nlike to use community-maintained configuration templates\n\n\nneed unattended bootstrapping of nodes\n\n\ndon\u2019t trust your coworkers",
            "title": "<i class=\"fa fa-home\"></i>"
        },
        {
            "location": "/#bundlewrap-documentation",
            "text": "Check out the  quickstart tutorial  to get started.  If you run into a problem that is not answered in these docs, please\nfind us on  IRC  or  Twitter . We\u2019re happy to help!",
            "title": "BundleWrap documentation"
        },
        {
            "location": "/#is-bundlewrap-the-right-tool-for-you",
            "text": "We think you will enjoy BundleWrap a lot if you:   know some Python  like to write your configuration from scratch and control every bit\n    of it  have lots of unique nodes  are trying to get a lot of existing systems under management  are NOT trying to handle a massive amount of nodes (let\u2019s say more\n    than 1000)  like to start small  don\u2019t want yet more stuff to run on your nodes (or mess with\n    appliances as little as possible)  prefer a simple tool to a fancy one  want as much as possible in git/hg/bzr  have strongly segmented internal networks   You might be better served with a different config management system if\nyou:   are already using a config management system and don\u2019t have any\n    major issues  hate Python and/or JSON  like to use community-maintained configuration templates  need unattended bootstrapping of nodes  don\u2019t trust your coworkers",
            "title": "Is BundleWrap the right tool for you?"
        },
        {
            "location": "/guide/quickstart/",
            "text": "Quickstart\n\n\nThis is the 10 minute intro into BundleWrap. Fasten your seatbelt.\n\n\nInstallation\n\n\nFirst, open a terminal and install BundleWrap:\n\n\npip install bundlewrap\n\n\n\nCreate a repository\n\n\nNow you'll need to create your \nrepository\n:\n\n\nmkdir my_bundlewrap_repo\ncd my_bundlewrap_repo\nbw repo create\n\n\n\n\nYou will note that some files have been created. Let's check them out:\n\n\ncat nodes.py\ncat groups.py\n\n\n\n\nThe contents should be fairly self-explanatory, but you can always check the \ndocs\n on these files if you want to go deeper.\n\n\nIt is highly recommended to use git or a similar tool to keep track of your repository. You may want to start doing that right away.\n\n\n\nAt this point you will want to edit \nnodes.py\n and maybe change \"localhost\" to the hostname of a system you have passwordless (including sudo) SSH access to.\n\n\nBundleWrap will honor your \n~/.ssh/config\n, so if \nssh mynode.example.com sudo id\n works without any password prompts in your terminal, you're good to go.\n\n\n\nRun a command\n\n\nThe first thing you can do is run a command on your army of one node:\n\n\nbw -a run node-1 \"uptime\"\n\n\n\nThe \n-a\n switch tells bw to automatically trust unknown SSH host keys (when you're connecting to a new node). By default, only known host keys will be accepted.\n\n\n\nYou should see something like this:\n\n\n\u203a node-1   20:16:26 up 34 days,  4:10,  0 users,  load average: 0.00, 0.01, 0.05\n\u2713 node-1  completed after 0.366s\n\n\n\nInstead of a node name (\"node-1\" in this case) you can also use a group name (such as \"all\") from your \ngroups.py\n.\n\n\nCreate a bundle\n\n\nBundleWrap stores node configuration in \nbundles\n. A bundle is a collection of \nitems\n such as files, system packages or users. To create your first bundle, type:\n\n\nbw repo bundle create mybundle\n\n\n\nNow that you have created your bundle, it's important to tell BundleWrap which nodes will have this bundle. You can assign bundles to nodes using either \ngroups.py\n or \nnodes.py\n, here we'll use the latter:\n\n\nnodes = {\n    'node-1': {\n        'bundles': (\n            \"mybundle\",\n        ),\n        'hostname': \"mynode-1.local\",\n    },\n}\n\n\n\nCreate a file template\n\n\nTo manage a file, you need two things:\n\n\n\n\na file item in your bundle\n\n\na template for the file contents\n\n\n\n\nAdd this to your \nbundles/mybundle/items.py\n:\n\n\nfiles = {\n    '/etc/motd': {\n        'content_type': 'mako',  # use the Mako template engine for this file\n        'source': \"mymotd\",  # filename of the template\n    },\n}\n\n\n\nThen write the file template:\n\n\nvim bundles/mybundle/files/mymotd\n\n\n\nYou can use this for example content:\n\n\nWelcome to ${node.name}!\n\n\n\nNote that the \nsource\n attribute in \nitems.py\n contains a path relative to the \nfiles\n directory of your bundle.\n\n\nApply configuration\n\n\nNow all that's left is to run \nbw apply\n:\n\n\nbw apply -i node-1\n\n\n\nBundleWrap will ask to replace your previous MOTD:\n\n\ni node-1  started at 2016-02-13 21:25:45\n? node-1\n? node-1  \u256d\u2500 file:/etc/motd\n? node-1  \u2502\n? node-1  \u2502  content\n? node-1  \u2502  --- <node>\n? node-1  \u2502  +++ <bundlewrap>\n? node-1  \u2502  @@ -1 +1 @@\n? node-1  \u2502  -your old motd\n? node-1  \u2502  +Welcome to node-1!\n? node-1  \u2502\n? node-1  \u2570\u2500 Fix file:/etc/motd? [Y/n]\n\n\n\n\nThat completes the quickstart tutorial!\n\n\nFurther reading\n\n\nHere are some suggestions on what to do next:\n\n\n\n\nset up \nSSH multiplexing\n for significantly better performance\n\n\ntake a moment to think about what groups and bundles you will create\n\n\nread up on how a \nBundleWrap repository\n is laid out\n\n\n...especially what \ntypes of items\n you can add to your bundles\n\n\nfamiliarize yourself with \nthe Mako template language\n\n\nexplore the \ncommand line interface\n\n\nfollow \n@bundlewrap\n on Twitter\n\n\n\n\nHave fun! If you have any questions, feel free to drop by \non IRC\n.",
            "title": "Quickstart"
        },
        {
            "location": "/guide/quickstart/#quickstart",
            "text": "This is the 10 minute intro into BundleWrap. Fasten your seatbelt.",
            "title": "Quickstart"
        },
        {
            "location": "/guide/quickstart/#installation",
            "text": "First, open a terminal and install BundleWrap:  pip install bundlewrap",
            "title": "Installation"
        },
        {
            "location": "/guide/quickstart/#create-a-repository",
            "text": "Now you'll need to create your  repository :  mkdir my_bundlewrap_repo\ncd my_bundlewrap_repo\nbw repo create  You will note that some files have been created. Let's check them out:  cat nodes.py\ncat groups.py  The contents should be fairly self-explanatory, but you can always check the  docs  on these files if you want to go deeper.  It is highly recommended to use git or a similar tool to keep track of your repository. You may want to start doing that right away.  At this point you will want to edit  nodes.py  and maybe change \"localhost\" to the hostname of a system you have passwordless (including sudo) SSH access to.  BundleWrap will honor your  ~/.ssh/config , so if  ssh mynode.example.com sudo id  works without any password prompts in your terminal, you're good to go.",
            "title": "Create a repository"
        },
        {
            "location": "/guide/quickstart/#run-a-command",
            "text": "The first thing you can do is run a command on your army of one node:  bw -a run node-1 \"uptime\"  The  -a  switch tells bw to automatically trust unknown SSH host keys (when you're connecting to a new node). By default, only known host keys will be accepted.  You should see something like this:  \u203a node-1   20:16:26 up 34 days,  4:10,  0 users,  load average: 0.00, 0.01, 0.05\n\u2713 node-1  completed after 0.366s  Instead of a node name (\"node-1\" in this case) you can also use a group name (such as \"all\") from your  groups.py .",
            "title": "Run a command"
        },
        {
            "location": "/guide/quickstart/#create-a-bundle",
            "text": "BundleWrap stores node configuration in  bundles . A bundle is a collection of  items  such as files, system packages or users. To create your first bundle, type:  bw repo bundle create mybundle  Now that you have created your bundle, it's important to tell BundleWrap which nodes will have this bundle. You can assign bundles to nodes using either  groups.py  or  nodes.py , here we'll use the latter:  nodes = {\n    'node-1': {\n        'bundles': (\n            \"mybundle\",\n        ),\n        'hostname': \"mynode-1.local\",\n    },\n}",
            "title": "Create a bundle"
        },
        {
            "location": "/guide/quickstart/#create-a-file-template",
            "text": "To manage a file, you need two things:   a file item in your bundle  a template for the file contents   Add this to your  bundles/mybundle/items.py :  files = {\n    '/etc/motd': {\n        'content_type': 'mako',  # use the Mako template engine for this file\n        'source': \"mymotd\",  # filename of the template\n    },\n}  Then write the file template:  vim bundles/mybundle/files/mymotd  You can use this for example content:  Welcome to ${node.name}!  Note that the  source  attribute in  items.py  contains a path relative to the  files  directory of your bundle.",
            "title": "Create a file template"
        },
        {
            "location": "/guide/quickstart/#apply-configuration",
            "text": "Now all that's left is to run  bw apply :  bw apply -i node-1  BundleWrap will ask to replace your previous MOTD:  i node-1  started at 2016-02-13 21:25:45\n? node-1\n? node-1  \u256d\u2500 file:/etc/motd\n? node-1  \u2502\n? node-1  \u2502  content\n? node-1  \u2502  --- <node>\n? node-1  \u2502  +++ <bundlewrap>\n? node-1  \u2502  @@ -1 +1 @@\n? node-1  \u2502  -your old motd\n? node-1  \u2502  +Welcome to node-1!\n? node-1  \u2502\n? node-1  \u2570\u2500 Fix file:/etc/motd? [Y/n]  That completes the quickstart tutorial!",
            "title": "Apply configuration"
        },
        {
            "location": "/guide/quickstart/#further-reading",
            "text": "Here are some suggestions on what to do next:   set up  SSH multiplexing  for significantly better performance  take a moment to think about what groups and bundles you will create  read up on how a  BundleWrap repository  is laid out  ...especially what  types of items  you can add to your bundles  familiarize yourself with  the Mako template language  explore the  command line interface  follow  @bundlewrap  on Twitter   Have fun! If you have any questions, feel free to drop by  on IRC .",
            "title": "Further reading"
        },
        {
            "location": "/guide/installation/",
            "text": "Installation\n\n\nYou may need to install \npip\n first. This can be accomplished through your distribution's package manager, e.g.:\n\n\naptitude install python-pip\n\n\nor the \nmanual instructions\n.\n\n\n\nUsing pip\n\n\nIt's as simple as:\n\n\npip install bundlewrap\n\n\n\nNote that you need at least Python 2.7 to run BundleWrap. Python 3 is supported as long as it's >= 3.3.\n\n\n\n\nFrom git\n\n\nThis type of install will give you the very latest (and thus possibly broken) bleeding edge version of BundleWrap.\nYou should only use this if you know what you're doing.\n\n\n\nThe instructions below are for installing on Ubuntu Server 12.10 (Quantal), but should also work for other versions of Ubuntu/Debian. If you're on some other distro, you will obviously have to adjust the package install commands.\n\n\n\nThe instructions assume you have root privileges.\n\n\n\nInstall basic requirements:\n\n\naptitude install build-essential git python-dev python-pip\n\n\n\nClone the GitHub repository:\n\n\ncd /opt\ngit clone https://github.com/bundlewrap/bundlewrap.git\n\n\n\nUse \npip install -e\n to install in \"development mode\":\n\n\npip install -e /opt/bundlewrap\n\n\n\nYou can now try running the \nbw\n command line utility:\n\n\nbw --help\n\n\n\nThat's it.\n\n\nTo update your install, just pull the git repository and have setup.py` check for new dependencies:\n\n\ncd /opt/bundlewrap\ngit pull\npython setup.py develop\n\n\n\n\n\nRequirements for managed systems\n\n\nWhile the following list might appear long, even very minimal systems should provide everything that's needed.\n\n\n\n\napt-get\n (only used with \npkg_apt\n items)\n\n\ncat\n\n\nchmod\n\n\nchown\n\n\ndpkg\n (only used with \npkg_apt\n items)\n\n\necho\n\n\nfile\n\n\nfind\n (only used with \ndirectory purging\n)\n\n\ngrep\n\n\ngroupadd\n\n\ngroupmod\n\n\nid\n\n\ninitctl\n (only used with \nsvc_upstart\n items)\n\n\nmkdir\n\n\nmv\n\n\npacman\n (only used with \npkg_pacman\n items)\n\n\nrm\n\n\nsftp-enabled SSH server (your home directory must be writable)\n\n\nsudo\n\n\nsha1sum\n\n\nstat\n\n\nsystemctl\n (only used with \nsvc_systemd\n items)\n\n\nuseradd\n\n\nusermod\n\n\n\n\nAdditionally, you need to pre-configure your SSH client so that it can connect to your nodes without having to type a password (including \nsudo\n on the node, which also must \nnot\n have the \nrequiretty\n option set).",
            "title": "Installation"
        },
        {
            "location": "/guide/installation/#installation",
            "text": "You may need to install  pip  first. This can be accomplished through your distribution's package manager, e.g.: aptitude install python-pip \n\nor the  manual instructions .",
            "title": "Installation"
        },
        {
            "location": "/guide/installation/#using-pip",
            "text": "It's as simple as:  pip install bundlewrap  Note that you need at least Python 2.7 to run BundleWrap. Python 3 is supported as long as it's >= 3.3.",
            "title": "Using pip"
        },
        {
            "location": "/guide/installation/#from-git",
            "text": "This type of install will give you the very latest (and thus possibly broken) bleeding edge version of BundleWrap.\nYou should only use this if you know what you're doing.  The instructions below are for installing on Ubuntu Server 12.10 (Quantal), but should also work for other versions of Ubuntu/Debian. If you're on some other distro, you will obviously have to adjust the package install commands.  The instructions assume you have root privileges.  Install basic requirements:  aptitude install build-essential git python-dev python-pip  Clone the GitHub repository:  cd /opt\ngit clone https://github.com/bundlewrap/bundlewrap.git  Use  pip install -e  to install in \"development mode\":  pip install -e /opt/bundlewrap  You can now try running the  bw  command line utility:  bw --help  That's it.  To update your install, just pull the git repository and have setup.py` check for new dependencies:  cd /opt/bundlewrap\ngit pull\npython setup.py develop",
            "title": "From git"
        },
        {
            "location": "/guide/installation/#requirements-for-managed-systems",
            "text": "While the following list might appear long, even very minimal systems should provide everything that's needed.   apt-get  (only used with  pkg_apt  items)  cat  chmod  chown  dpkg  (only used with  pkg_apt  items)  echo  file  find  (only used with  directory purging )  grep  groupadd  groupmod  id  initctl  (only used with  svc_upstart  items)  mkdir  mv  pacman  (only used with  pkg_pacman  items)  rm  sftp-enabled SSH server (your home directory must be writable)  sudo  sha1sum  stat  systemctl  (only used with  svc_systemd  items)  useradd  usermod   Additionally, you need to pre-configure your SSH client so that it can connect to your nodes without having to type a password (including  sudo  on the node, which also must  not  have the  requiretty  option set).",
            "title": "Requirements for managed systems"
        },
        {
            "location": "/guide/cli/",
            "text": "Command Line Interface\n\n\nThe \nbw\n utility is BundleWrap's command line interface.\n\n\nThis page is not meant as a complete reference. It provides a starting point to explore the various subcommands. If you're looking for details, \n--help\n is your friend.\n\n\n\nbw apply\n\n\nbw apply -i mynode\n\n\n\nThe most important and most used part of BundleWrap, \nbw apply\n will apply your configuration to a set of \nnodes\n. By default, it operates in a non-interactive mode. When you're trying something new or are otherwise unsure of some changes, use the \n-i\n switch to have BundleWrap interactively ask before each change is made.\n\n\n\n\nbw run\n\n\n$ bw run mygroup \"uname -a\"\n\n\n\nUnsurprisingly, the \nrun\n subcommand is used to run commands on nodes.\n\n\nAs with most commands that accept node names, you can also give a \ngroup\n name or any combination of node and group names, separated by commas (without spaces, e.g. \nnode1,group2,node3\n). A third option is to use a bundle selector like \nbundle:my_bundle\n. It will select all nodes with the named \nbundle\n. You can freely mix and match node names, group names, and bundle selectors.\n\n\nNegation is also possible for bundles and groups. \n!bundle:foo\n will add all nodes without the foo bundle, while \n!group:foo\n will add all nodes that aren't in the foo group.\n\n\n\n\nbw nodes and bw groups\n\n\n$ bw nodes --hostnames | xargs -n 1 ping -c 1\n\n\n\nWith these commands you can quickly get a list of all nodes and groups in your \nrepository\n. The example above uses \n--hostnames\n to get a list of all DNS names for your nodes and send a ping to each one.\n\n\n\n\nbw debug\n\n\n$ bw debug\nbundlewrap X.Y.Z interactive repository inspector\n> You can access the current repository as 'repo'.\n>>> len(repo.nodes)\n121\n\n\n\nThis command will drop you into a Python shell with direct access to BundleWrap's \nAPI\n. Once you're familiar with it, it can be a very powerful tool.\n\n\n\n\nbw plot\n\n\nYou'll need \nGraphviz\n installed on your machine for this to be useful.\n\n\n\n$ bw plot node mynode | dot -Tsvg -omynode.svg\n\n\n\nYou won't be using this every day, but it's pretty cool. The above command will create an SVG file (you can open these in your browser) that shows the item dependency graph for the given node. You will see bundles as dashed rectangles, static dependencies (defined in BundleWrap itself) in green, auto-generated dependencies (calculated dynamically each time you run \nbw apply\n) in blue and dependencies you defined yourself in red.\n\n\nIt offers an interesting view into the internal complexities BundleWrap has to deal with when figuring out the order in which your items can be applied to your node.\n\n\n\n\nbw test\n\n\n$ bw test\n\u2713 node1  samba  pkg_apt:samba\n\u2718 node1  samba  file:/etc/samba/smb.conf\n\n[...]\n\n+----- traceback from worker ------\n|\n|  Traceback (most recent call last):\n|    File \"bundlewrap/concurrency.py\", line 78, in _worker_process\n|      return_value = target(*msg['args'], **msg['kwargs'])\n|    File \"<string>\", line 378, in test\n|  BundleError: file:/etc/samba/smb.conf from bundle 'samba' refers to missing file '/path/to/bundlewrap/repo/bundles/samba/files/smb.conf'\n|\n+----------------------------------\n\n\n\n\nThis command is meant to be run automatically like a test suite after every commit. It will try to catch any errors in your bundles and file templates by initializing every item for every node (but without touching the network).",
            "title": "CLI"
        },
        {
            "location": "/guide/cli/#command-line-interface",
            "text": "The  bw  utility is BundleWrap's command line interface.  This page is not meant as a complete reference. It provides a starting point to explore the various subcommands. If you're looking for details,  --help  is your friend.",
            "title": "Command Line Interface"
        },
        {
            "location": "/guide/cli/#bw-apply",
            "text": "bw apply -i mynode  The most important and most used part of BundleWrap,  bw apply  will apply your configuration to a set of  nodes . By default, it operates in a non-interactive mode. When you're trying something new or are otherwise unsure of some changes, use the  -i  switch to have BundleWrap interactively ask before each change is made.",
            "title": "bw apply"
        },
        {
            "location": "/guide/cli/#bw-run",
            "text": "$ bw run mygroup \"uname -a\"  Unsurprisingly, the  run  subcommand is used to run commands on nodes.  As with most commands that accept node names, you can also give a  group  name or any combination of node and group names, separated by commas (without spaces, e.g.  node1,group2,node3 ). A third option is to use a bundle selector like  bundle:my_bundle . It will select all nodes with the named  bundle . You can freely mix and match node names, group names, and bundle selectors.  Negation is also possible for bundles and groups.  !bundle:foo  will add all nodes without the foo bundle, while  !group:foo  will add all nodes that aren't in the foo group.",
            "title": "bw run"
        },
        {
            "location": "/guide/cli/#bw-nodes-and-bw-groups",
            "text": "$ bw nodes --hostnames | xargs -n 1 ping -c 1  With these commands you can quickly get a list of all nodes and groups in your  repository . The example above uses  --hostnames  to get a list of all DNS names for your nodes and send a ping to each one.",
            "title": "bw nodes and bw groups"
        },
        {
            "location": "/guide/cli/#bw-debug",
            "text": "$ bw debug\nbundlewrap X.Y.Z interactive repository inspector\n> You can access the current repository as 'repo'.\n>>> len(repo.nodes)\n121  This command will drop you into a Python shell with direct access to BundleWrap's  API . Once you're familiar with it, it can be a very powerful tool.",
            "title": "bw debug"
        },
        {
            "location": "/guide/cli/#bw-plot",
            "text": "You'll need  Graphviz  installed on your machine for this to be useful.  $ bw plot node mynode | dot -Tsvg -omynode.svg  You won't be using this every day, but it's pretty cool. The above command will create an SVG file (you can open these in your browser) that shows the item dependency graph for the given node. You will see bundles as dashed rectangles, static dependencies (defined in BundleWrap itself) in green, auto-generated dependencies (calculated dynamically each time you run  bw apply ) in blue and dependencies you defined yourself in red.  It offers an interesting view into the internal complexities BundleWrap has to deal with when figuring out the order in which your items can be applied to your node.",
            "title": "bw plot"
        },
        {
            "location": "/guide/cli/#bw-test",
            "text": "$ bw test\n\u2713 node1  samba  pkg_apt:samba\n\u2718 node1  samba  file:/etc/samba/smb.conf\n\n[...]\n\n+----- traceback from worker ------\n|\n|  Traceback (most recent call last):\n|    File \"bundlewrap/concurrency.py\", line 78, in _worker_process\n|      return_value = target(*msg['args'], **msg['kwargs'])\n|    File \"<string>\", line 378, in test\n|  BundleError: file:/etc/samba/smb.conf from bundle 'samba' refers to missing file '/path/to/bundlewrap/repo/bundles/samba/files/smb.conf'\n|\n+----------------------------------  This command is meant to be run automatically like a test suite after every commit. It will try to catch any errors in your bundles and file templates by initializing every item for every node (but without touching the network).",
            "title": "bw test"
        },
        {
            "location": "/guide/env/",
            "text": "Environment Variables\n\n\nBW_ADD_HOST_KEYS\n\n\nAs BundleWrap uses OpenSSH to connect to hosts, host key checking is involved. By default, strict host key checking is activated. This might not be suitable for your setup. You can set this variable to \n1\n to cause BundleWrap to set the OpenSSH option \nStrictHostKeyChecking=no\n.\n\n\nYou can also use \nbw -a ...\n to achieve the same effect.\n\n\n\n\nBW_COLORS\n\n\nColors are enabled by default. Setting this variable to \n0\n tells BundleWrap to never use any ANSI color escape sequences.\n\n\n\n\nBW_DEBUG_LOG_DIR\n\n\nSet this to an existing directory path to have BundleWrap write debug logs there (even when you're running \nbw\n without \n--debug\n).\n\n\nDebug logs are verbose and BundleWrap does not rotate them for you. Putting them on a tmpfs or ramdisk will save your SSD and get rid of old logs every time you reboot your machine.\n\n\n\n\n\nBW_HARDLOCK_EXPIRY\n\n\nHard locks\n are automatically ignored after some time. By default, it's \n\"8h\"\n. You can use this variable to override that default.\n\n\n\n\nBW_IDENTITY\n\n\nWhen BundleWrap \nlocks\n a node, it stores a short description about \"you\". By default, this is the string \n$USER@$HOSTNAME\n, e.g. \njohn@mymachine\n. You can use \nBW_IDENTITY\n to specify a custom string. (No variables will be evaluated in user supplied strings.)\n\n\n\n\nBW_ITEM_WORKERS\n and \nBW_NODE_WORKERS\n\n\nBundleWrap attempts to parallelize work. These two options specify the number of nodes and items, respectively, which will be handled concurrently. To be more precise, when setting \nBW_NODE_WORKERS=8\n and \nBW_ITEM_WORKERS=2\n, BundleWrap will work on eight nodes in parallel, each handling two items in parallel.\n\n\nYou can also use the command line options \n-p\n and \n-P\n, e.g. \nbw apply -p ... -P ... ...\n, to achieve the same effect. Command line arguments override environment variables.\n\n\nThere is no single default for these values. For example, when running \nbw apply\n, four nodes are being handled by default. However, when running \nbw test\n, only one node will be tested by default. \nBW_NODE_WORKERS\n and \nBW_ITEM_WORKERS\n apply to \nall\n these operations.\n\n\nNote that you should not set these variables to very high values. First, it can cause high memory consumption on your machine. Second, not all SSH servers can handle massive parallelism. Please refer to your OpenSSH documentation on how to tune your servers for these situations.\n\n\n\n\nBW_REPO_PATH\n\n\nSet this to a path pointing to your BundleWrap repository. If unset, the current working directory is used. Can be overridden with \nbw --repository PATH\n. Keep in mind that \nbw\n will also look for a repository in all parent directories until it finds one.\n\n\n\n\nBW_SOFTLOCK_EXPIRY\n\n\nSoft locks\n are automatically removed from nodes after some time. By default, it's \n\"8h\"\n. You can use this variable to override that default.\n\n\n\n\nBW_SSH_ARGS\n\n\nExtra arguments to include in every call to \nssh\n BundleWrap makes. Set this to \"-F ~/.ssh/otherconf\" to use a different SSH config with BundleWrap.\n\n\n\n\nBW_TABLE_STYLE\n\n\nBy default, BundleWrap uses Unicode box-drawing characters at various points in its output. Setting this env var to one of the following values changes that behavior:\n\n\n\n\nascii\nuse only simple ASCII characters to render tables (useful if your font doesn't properly align box-drawing characters)\n\n\ngrep\nmake output more \ngrep\n- and \ncut\n-friendly\n\n\n\n\n\n\n\nBW_VAULT_DUMMY_MODE\n\n\nSetting this to \n1\n will make \nrepo.vault\n return dummy values for every \nsecret\n. This is useful for running \nbw test\n on a CI server that you don't want to trust with your \n.secrets.cfg\n.",
            "title": "Environment Variables"
        },
        {
            "location": "/guide/env/#environment-variables",
            "text": "",
            "title": "Environment Variables"
        },
        {
            "location": "/guide/env/#bw_add_host_keys",
            "text": "As BundleWrap uses OpenSSH to connect to hosts, host key checking is involved. By default, strict host key checking is activated. This might not be suitable for your setup. You can set this variable to  1  to cause BundleWrap to set the OpenSSH option  StrictHostKeyChecking=no .  You can also use  bw -a ...  to achieve the same effect.",
            "title": "BW_ADD_HOST_KEYS"
        },
        {
            "location": "/guide/env/#bw_colors",
            "text": "Colors are enabled by default. Setting this variable to  0  tells BundleWrap to never use any ANSI color escape sequences.",
            "title": "BW_COLORS"
        },
        {
            "location": "/guide/env/#bw_debug_log_dir",
            "text": "Set this to an existing directory path to have BundleWrap write debug logs there (even when you're running  bw  without  --debug ).  Debug logs are verbose and BundleWrap does not rotate them for you. Putting them on a tmpfs or ramdisk will save your SSD and get rid of old logs every time you reboot your machine.",
            "title": "BW_DEBUG_LOG_DIR"
        },
        {
            "location": "/guide/env/#bw_hardlock_expiry",
            "text": "Hard locks  are automatically ignored after some time. By default, it's  \"8h\" . You can use this variable to override that default.",
            "title": "BW_HARDLOCK_EXPIRY"
        },
        {
            "location": "/guide/env/#bw_identity",
            "text": "When BundleWrap  locks  a node, it stores a short description about \"you\". By default, this is the string  $USER@$HOSTNAME , e.g.  john@mymachine . You can use  BW_IDENTITY  to specify a custom string. (No variables will be evaluated in user supplied strings.)",
            "title": "BW_IDENTITY"
        },
        {
            "location": "/guide/env/#bw_item_workers-and-bw_node_workers",
            "text": "BundleWrap attempts to parallelize work. These two options specify the number of nodes and items, respectively, which will be handled concurrently. To be more precise, when setting  BW_NODE_WORKERS=8  and  BW_ITEM_WORKERS=2 , BundleWrap will work on eight nodes in parallel, each handling two items in parallel.  You can also use the command line options  -p  and  -P , e.g.  bw apply -p ... -P ... ... , to achieve the same effect. Command line arguments override environment variables.  There is no single default for these values. For example, when running  bw apply , four nodes are being handled by default. However, when running  bw test , only one node will be tested by default.  BW_NODE_WORKERS  and  BW_ITEM_WORKERS  apply to  all  these operations.  Note that you should not set these variables to very high values. First, it can cause high memory consumption on your machine. Second, not all SSH servers can handle massive parallelism. Please refer to your OpenSSH documentation on how to tune your servers for these situations.",
            "title": "BW_ITEM_WORKERS and BW_NODE_WORKERS"
        },
        {
            "location": "/guide/env/#bw_repo_path",
            "text": "Set this to a path pointing to your BundleWrap repository. If unset, the current working directory is used. Can be overridden with  bw --repository PATH . Keep in mind that  bw  will also look for a repository in all parent directories until it finds one.",
            "title": "BW_REPO_PATH"
        },
        {
            "location": "/guide/env/#bw_softlock_expiry",
            "text": "Soft locks  are automatically removed from nodes after some time. By default, it's  \"8h\" . You can use this variable to override that default.",
            "title": "BW_SOFTLOCK_EXPIRY"
        },
        {
            "location": "/guide/env/#bw_ssh_args",
            "text": "Extra arguments to include in every call to  ssh  BundleWrap makes. Set this to \"-F ~/.ssh/otherconf\" to use a different SSH config with BundleWrap.",
            "title": "BW_SSH_ARGS"
        },
        {
            "location": "/guide/env/#bw_table_style",
            "text": "By default, BundleWrap uses Unicode box-drawing characters at various points in its output. Setting this env var to one of the following values changes that behavior:   ascii use only simple ASCII characters to render tables (useful if your font doesn't properly align box-drawing characters)  grep make output more  grep - and  cut -friendly",
            "title": "BW_TABLE_STYLE"
        },
        {
            "location": "/guide/env/#bw_vault_dummy_mode",
            "text": "Setting this to  1  will make  repo.vault  return dummy values for every  secret . This is useful for running  bw test  on a CI server that you don't want to trust with your  .secrets.cfg .",
            "title": "BW_VAULT_DUMMY_MODE"
        },
        {
            "location": "/guide/item_file_templates/",
            "text": "Writing file templates\n\n\nBundleWrap can use \nMako\n or \nJinja2\n for file templating. This enables you to dynamically contruct your config files. Templates reside in the \nfiles\n subdirectory of a bundle and are bound to a file item using the \nsource\n \nattribute\n. This page explains how to get started with Mako.\n\n\nThe most basic example would be:\n\n\nHello, this is ${node.name}!\n\n\n\nAfter template rendering, it would look like this:\n\n\nHello, this is myexamplenodename!\n\n\n\nAs you can see, \n${...}\n can be used to insert the value of a context variable into the rendered file. By default, you have access to two variables in every template: \nnode\n and \nrepo\n. They are \nbundlewrap.node.Node\n and \nbundlewrap.repo.Repository\n objects, respectively. You can learn more about the attributes and methods of these objects in the \nAPI docs\n, but here are a few examples:\n\n\n\n\nExamples\n\n\ninserts the DNS hostname of the current node\n\n\n${node.hostname}\n\n\n\n\n\na list of all nodes in your repo\n\n\n% for node in repo.nodes:\n${node.name}\n% endfor\n\n\n\n\n\nmake exceptions for certain nodes\n\n\n% if node.name == \"node1\":\noption = foo\n% elif node.name in (\"node2\", \"node3\"):\noption = bar\n% else:\noption = baz\n% endif\n\n\n\n\n\ncheck for group membership\n\n\n% if node.in_group(\"sparkle\"):\nenable_sparkles = 1\n% endif\n\n\n\n\n\ncheck for membership in any of several groups\n\n\n% if node.in_any_group((\"sparkle\", \"shiny\")):\nenable_fancy = 1\n% endif\n\n\n\n\n\ncheck for bundle\n\n\n% if node.has_bundle(\"sparkle\"):\nenable_sparkles = 1\n% endif\n\n\n\n\n\ncheck for any of several bundles\n\n\n% if node.has_any_bundle((\"sparkle\", \"shiny\")):\nenable_fancy = 1\n% endif\n\n\n\n\n\nlist all nodes in a group\n\n\n% for gnode in repo.get_group(\"mygroup\").nodes:\n${gnode.name}\n% endfor\n\n\n\n\n\nWorking with node metadata\n\n\nQuite often you will attach custom metadata to your nodes in \nnodes.py\n, e.g.:\n\n\nnodes = {\n    \"node1\": {\n        \"metadata\": {\n            \"interfaces\": {\n                \"eth0\": \"10.1.1.47\",\n                \"eth1\": \"10.1.2.47\",\n            },\n        },\n    },\n}\n\n\n\nYou can easily access this information in templates:\n\n\n% for interface, ip in sorted(node.metadata[\"interfaces\"].items()):\ninterface ${interface}\n    ip = ${ip}\n% endfor\n\n\n\nThis template will render to:\n\n\ninterface eth0\n    ip = 10.1.1.47\ninterface eth1\n    ip = 10.1.2.47",
            "title": "File templates"
        },
        {
            "location": "/guide/item_file_templates/#writing-file-templates",
            "text": "BundleWrap can use  Mako  or  Jinja2  for file templating. This enables you to dynamically contruct your config files. Templates reside in the  files  subdirectory of a bundle and are bound to a file item using the  source   attribute . This page explains how to get started with Mako.  The most basic example would be:  Hello, this is ${node.name}!  After template rendering, it would look like this:  Hello, this is myexamplenodename!  As you can see,  ${...}  can be used to insert the value of a context variable into the rendered file. By default, you have access to two variables in every template:  node  and  repo . They are  bundlewrap.node.Node  and  bundlewrap.repo.Repository  objects, respectively. You can learn more about the attributes and methods of these objects in the  API docs , but here are a few examples:",
            "title": "Writing file templates"
        },
        {
            "location": "/guide/item_file_templates/#examples",
            "text": "inserts the DNS hostname of the current node  ${node.hostname}   a list of all nodes in your repo  % for node in repo.nodes:\n${node.name}\n% endfor   make exceptions for certain nodes  % if node.name == \"node1\":\noption = foo\n% elif node.name in (\"node2\", \"node3\"):\noption = bar\n% else:\noption = baz\n% endif   check for group membership  % if node.in_group(\"sparkle\"):\nenable_sparkles = 1\n% endif   check for membership in any of several groups  % if node.in_any_group((\"sparkle\", \"shiny\")):\nenable_fancy = 1\n% endif   check for bundle  % if node.has_bundle(\"sparkle\"):\nenable_sparkles = 1\n% endif   check for any of several bundles  % if node.has_any_bundle((\"sparkle\", \"shiny\")):\nenable_fancy = 1\n% endif   list all nodes in a group  % for gnode in repo.get_group(\"mygroup\").nodes:\n${gnode.name}\n% endfor",
            "title": "Examples"
        },
        {
            "location": "/guide/item_file_templates/#working-with-node-metadata",
            "text": "Quite often you will attach custom metadata to your nodes in  nodes.py , e.g.:  nodes = {\n    \"node1\": {\n        \"metadata\": {\n            \"interfaces\": {\n                \"eth0\": \"10.1.1.47\",\n                \"eth1\": \"10.1.2.47\",\n            },\n        },\n    },\n}  You can easily access this information in templates:  % for interface, ip in sorted(node.metadata[\"interfaces\"].items()):\ninterface ${interface}\n    ip = ${ip}\n% endfor  This template will render to:  interface eth0\n    ip = 10.1.1.47\ninterface eth1\n    ip = 10.1.2.47",
            "title": "Working with node metadata"
        },
        {
            "location": "/guide/secrets/",
            "text": "Handling secrets\n\n\nWe strongly recommend \nnot\n putting any sensitive information such as passwords or private keys into your repository. This page describes the helpers available in BundleWrap to manage those secrets without checking them into version control.\n\n\nMost of the functions described here return lazy \nFault objects\n.\n\n\n\n\n\n.secrets.cfg\n\n\nWhen you initially ran \nbw repo create\n, a file called \n.secrets.cfg\n was put into the root level of your repo. It's an INI-style file that by default contains two random keys BundleWrap uses to protect your secrets.\n\n\nYou should never commit \n.secrets.cfg\n. Immediately add it to your \n.gitignore\n or equivalent.\n\n\n\n\n\nDerived passwords\n\n\nIn some cases, you can control (i.e. manage with BundleWrap) both ends of the authentication process. A common example is a config file for a web application that holds credentials for a database also managed by BundleWrap. In this case, you don't really care what the password is, you just want it to be the same on both sides.\n\n\nTo accomplish that, just write this in your template (Mako syntax shown here):\n\n\ndatabase_user = \"foo\"\ndatabase_password = \"${repo.vault.password_for(\"my database\")}\"\n\n\n\n\nIn your bundle, you can then configure your database user like this:\n\n\npostgres_roles = {\n    \"foo\": {\n        'password': repo.vault.password_for(\"my database\"),\n    },\n}\n\n\n\nIt doesn't really matter what string you call \npassword_for()\n with, it just has to be the same on both ends. BundleWrap will then use that string, combine it with the default key called \ngenerate\n in your \n.secrets.cfg\n and derive a random password from that.\n\n\nThis makes it easy to change all your passwords at once (e.g. when an employee leaves or when required for compliance reasons) by rotating keys.\n\n\nHowever, it also means you have to guard your \n.secrets.cfg\n very closely. If it is compromised, so are \nall\n your passwords. Use your own judgement.\n\n\n\n\"Human\" passwords\n\n\nAs an alternative to \npassword_for()\n, which generates random strings, you can use \nhuman_password_for()\n.It generates strings like \nWiac-Kaobl-Teuh-Kumd-40\n. They are easier to handle for human beings. You might want to use them if you have to type those passwords on a regular basis.\n\n\n\n\nStatic passwords\n\n\nWhen you need to store a specific password, you can encrypt it symmetrically:\n\n\n$ bw debug -c \"print(repo.vault.encrypt('my password'))\"\ngAAAA[...]mrVMA==\n\n\n\n\nYou can then use this encrypted password in a template like this:\n\n\ndatabase_user = \"foo\"\ndatabase_password = \"${repo.vault.decrypt(\"gAAAA[...]mrVMA==\")}\"\n\n\n\n\n\n\nFiles\n\n\nYou can also encrypt entire files:\n\n\n$ bw debug -c \"repo.vault.encrypt_file('/my/secret.file', 'encrypted.file'))\"\n\n\n\nEncrypted files are always read and written relative to the \ndata/\n subdirectory of your repo.\n\n\n\nIf the source file was encoded using UTF-8, you can then simply pass the decrypted content into a file item:\n\n\nfiles = {\n    \"/secret\": {\n        'content': repo.vault.decrypt_file(\"encrypted.file\"),\n    },\n}\n\n\n\nIf the source file is binary however (or any encoding other than UTF-8), you must use base64:\n\n\nfiles = {\n    \"/secret\": {\n        'content': repo.vault.decrypt_file_as_base64(\"encrypted.file\"),\n        'content_type': 'base64',\n    },\n}\n\n\n\n\n\nKey management\n\n\nMultiple keys\n\n\nYou can always add more keys to your \n.secrets.cfg\n, but you should keep the defaults around. Adding more keys makes it possible to give different keys to different teams. \nBy default, BundleWrap will skip items it can't find the required keys for\n.\n\n\nWhen using \n.password_for()\n, \n.decrypt()\n etc., you can provide a \nkey\n argument to select the key:\n\n\nrepo.vault.password_for(\"some database\", key=\"devops\")\n\n\n\n\n\nRotating keys\n\n\nThis is applicable mostly to \n.password_for()\n. The other methods use symmetric encryption and require manually updating the encrypted text after the key has changed.\n\n\n\nYou can generate a new key by running \nbw debug -c \"print(repo.vault.random_key())\"\n. Place the result in your \n.secrets.cfg\n. Then you need to distribute the new key to your team and run \nbw apply\n for all your nodes.",
            "title": "Handling secrets"
        },
        {
            "location": "/guide/secrets/#handling-secrets",
            "text": "We strongly recommend  not  putting any sensitive information such as passwords or private keys into your repository. This page describes the helpers available in BundleWrap to manage those secrets without checking them into version control.  Most of the functions described here return lazy  Fault objects .",
            "title": "Handling secrets"
        },
        {
            "location": "/guide/secrets/#secretscfg",
            "text": "When you initially ran  bw repo create , a file called  .secrets.cfg  was put into the root level of your repo. It's an INI-style file that by default contains two random keys BundleWrap uses to protect your secrets.  You should never commit  .secrets.cfg . Immediately add it to your  .gitignore  or equivalent.",
            "title": ".secrets.cfg"
        },
        {
            "location": "/guide/secrets/#derived-passwords",
            "text": "In some cases, you can control (i.e. manage with BundleWrap) both ends of the authentication process. A common example is a config file for a web application that holds credentials for a database also managed by BundleWrap. In this case, you don't really care what the password is, you just want it to be the same on both sides.  To accomplish that, just write this in your template (Mako syntax shown here):  database_user = \"foo\"\ndatabase_password = \"${repo.vault.password_for(\"my database\")}\"  In your bundle, you can then configure your database user like this:  postgres_roles = {\n    \"foo\": {\n        'password': repo.vault.password_for(\"my database\"),\n    },\n}  It doesn't really matter what string you call  password_for()  with, it just has to be the same on both ends. BundleWrap will then use that string, combine it with the default key called  generate  in your  .secrets.cfg  and derive a random password from that.  This makes it easy to change all your passwords at once (e.g. when an employee leaves or when required for compliance reasons) by rotating keys.  However, it also means you have to guard your  .secrets.cfg  very closely. If it is compromised, so are  all  your passwords. Use your own judgement.",
            "title": "Derived passwords"
        },
        {
            "location": "/guide/secrets/#human-passwords",
            "text": "As an alternative to  password_for() , which generates random strings, you can use  human_password_for() .It generates strings like  Wiac-Kaobl-Teuh-Kumd-40 . They are easier to handle for human beings. You might want to use them if you have to type those passwords on a regular basis.",
            "title": "\"Human\" passwords"
        },
        {
            "location": "/guide/secrets/#static-passwords",
            "text": "When you need to store a specific password, you can encrypt it symmetrically:  $ bw debug -c \"print(repo.vault.encrypt('my password'))\"\ngAAAA[...]mrVMA==  You can then use this encrypted password in a template like this:  database_user = \"foo\"\ndatabase_password = \"${repo.vault.decrypt(\"gAAAA[...]mrVMA==\")}\"",
            "title": "Static passwords"
        },
        {
            "location": "/guide/secrets/#files",
            "text": "You can also encrypt entire files:  $ bw debug -c \"repo.vault.encrypt_file('/my/secret.file', 'encrypted.file'))\"  Encrypted files are always read and written relative to the  data/  subdirectory of your repo.  If the source file was encoded using UTF-8, you can then simply pass the decrypted content into a file item:  files = {\n    \"/secret\": {\n        'content': repo.vault.decrypt_file(\"encrypted.file\"),\n    },\n}  If the source file is binary however (or any encoding other than UTF-8), you must use base64:  files = {\n    \"/secret\": {\n        'content': repo.vault.decrypt_file_as_base64(\"encrypted.file\"),\n        'content_type': 'base64',\n    },\n}",
            "title": "Files"
        },
        {
            "location": "/guide/secrets/#key-management",
            "text": "",
            "title": "Key management"
        },
        {
            "location": "/guide/secrets/#multiple-keys",
            "text": "You can always add more keys to your  .secrets.cfg , but you should keep the defaults around. Adding more keys makes it possible to give different keys to different teams.  By default, BundleWrap will skip items it can't find the required keys for .  When using  .password_for() ,  .decrypt()  etc., you can provide a  key  argument to select the key:  repo.vault.password_for(\"some database\", key=\"devops\")",
            "title": "Multiple keys"
        },
        {
            "location": "/guide/secrets/#rotating-keys",
            "text": "This is applicable mostly to  .password_for() . The other methods use symmetric encryption and require manually updating the encrypted text after the key has changed.  You can generate a new key by running  bw debug -c \"print(repo.vault.random_key())\" . Place the result in your  .secrets.cfg . Then you need to distribute the new key to your team and run  bw apply  for all your nodes.",
            "title": "Rotating keys"
        },
        {
            "location": "/guide/locks/",
            "text": "Locking\n\n\nBundleWrap's decentralized nature makes it necessary to coordinate actions between users of a shared repository. Locking is an important part of collaborating using BundleWrap.\n\n\nHard locks\n\n\nSince very early in the history of BundleWrap, what we call \"hard locks\" were used to prevent multiple users from using \nbw apply\n on the same node at the same time. When BundleWrap finds a hard lock on a node in interactive mode, it will display information about who acquired the lock (and when) and will ask whether to ignore the lock or abort the process. In non-interactive mode, the operation is always cancelled for the node in question unless \n--force\n is used.\n\n\nSoft locks\n\n\nMany teams these days are using a workflow based on pull requests. A common problem here is that changes from a feature branch might already have been applied to a set of nodes, while the master branch is still lacking these changes. While the pull request is open and waiting for review, other users might rightly use the master branch to apply to all nodes, reverting changes made by the feature branch. This can be a major nuisance.\n\n\nAs of version 2.6.0, BundleWrap provides \"soft locks\" to prevent this. The author of a feature branch can now lock the node so only he or she can use \nbw apply\n on it:\n\n\n$ bw lock add node1\n\u2713 node1  locked with ID B9JS (expires in 8h)\n\n\n\nThis will prevent all other users from changing any items on the node for the next 8 hours. BundleWrap will tell users apart by their \nBW_IDENTITY\n. Now say someone else is reviewing the pull request and wants to use \nbw apply\n, while still keeping others out and the original author in. This can be done by simply locking the node \nagain\n as the reviewer. Nodes can have many soft locks. Soft locks act as an exemption from a general ban on changing items that goes into effect as soon as one or more soft locks are present on the node. Of course, if no soft locks are present, anyone can change any item.\n\n\nYou can list all soft locks on a node with:\n\n\n$ bw lock show node1\ni node1  ID    Created              Expires              User   Items  Comment\n\u203a node1  Y1KD  2016-05-25 21:30:25  2016-05-26 05:30:25  alice  *      locks are awesome\n\u203a node1  B9JS  2016-05-24 13:10:11  2016-05-27 08:10:11  bob    *      me too\n\n\n\nNote that each lock is identified by a case-insensitive 4-character ID that can be used to remove the lock:\n\n\n$ bw lock remove node1 y1kd\n\u2713 node1  lock Y1KD removed\n\n\n\nExpired locks are automatically and silently purged whenever BundleWrap has the opportunity. Be sure to check out \nbw lock add --help\n for how to customize expiration time, add a short comment explaining the reason for the lock, or lock only certain items. Using \nbw apply\n on a soft locked node is not an error and affected items will simply be skipped.",
            "title": "Locking"
        },
        {
            "location": "/guide/locks/#locking",
            "text": "BundleWrap's decentralized nature makes it necessary to coordinate actions between users of a shared repository. Locking is an important part of collaborating using BundleWrap.",
            "title": "Locking"
        },
        {
            "location": "/guide/locks/#hard-locks",
            "text": "Since very early in the history of BundleWrap, what we call \"hard locks\" were used to prevent multiple users from using  bw apply  on the same node at the same time. When BundleWrap finds a hard lock on a node in interactive mode, it will display information about who acquired the lock (and when) and will ask whether to ignore the lock or abort the process. In non-interactive mode, the operation is always cancelled for the node in question unless  --force  is used.",
            "title": "Hard locks"
        },
        {
            "location": "/guide/locks/#soft-locks",
            "text": "Many teams these days are using a workflow based on pull requests. A common problem here is that changes from a feature branch might already have been applied to a set of nodes, while the master branch is still lacking these changes. While the pull request is open and waiting for review, other users might rightly use the master branch to apply to all nodes, reverting changes made by the feature branch. This can be a major nuisance.  As of version 2.6.0, BundleWrap provides \"soft locks\" to prevent this. The author of a feature branch can now lock the node so only he or she can use  bw apply  on it:  $ bw lock add node1\n\u2713 node1  locked with ID B9JS (expires in 8h)  This will prevent all other users from changing any items on the node for the next 8 hours. BundleWrap will tell users apart by their  BW_IDENTITY . Now say someone else is reviewing the pull request and wants to use  bw apply , while still keeping others out and the original author in. This can be done by simply locking the node  again  as the reviewer. Nodes can have many soft locks. Soft locks act as an exemption from a general ban on changing items that goes into effect as soon as one or more soft locks are present on the node. Of course, if no soft locks are present, anyone can change any item.  You can list all soft locks on a node with:  $ bw lock show node1\ni node1  ID    Created              Expires              User   Items  Comment\n\u203a node1  Y1KD  2016-05-25 21:30:25  2016-05-26 05:30:25  alice  *      locks are awesome\n\u203a node1  B9JS  2016-05-24 13:10:11  2016-05-27 08:10:11  bob    *      me too  Note that each lock is identified by a case-insensitive 4-character ID that can be used to remove the lock:  $ bw lock remove node1 y1kd\n\u2713 node1  lock Y1KD removed  Expired locks are automatically and silently purged whenever BundleWrap has the opportunity. Be sure to check out  bw lock add --help  for how to customize expiration time, add a short comment explaining the reason for the lock, or lock only certain items. Using  bw apply  on a soft locked node is not an error and affected items will simply be skipped.",
            "title": "Soft locks"
        },
        {
            "location": "/guide/dev_item/",
            "text": "Custom item types\n\n\nStep 0: Understand statedicts\n\n\nTo represent supposed vs. actual state, BundleWrap uses statedicts. These are\nnormal Python dictionaries with some restrictions:\n\n\n\n\nkeys must be Unicode text\n\n\nevery value must be of one of these simple data types:\n\n\nbool\n\n\nfloat\n\n\nint\n\n\nUnicode text\n\n\nNone\n\n\n\n\n\n\n...or a list/tuple containing only instances of one of the types above\n\n\n\n\nAdditional information can be stored in statedicts by using keys that start with an underscore. You may only use this for caching purposes (e.g. storing rendered file template content while the \"real\" sdict information only contains a hash of this content). BundleWrap will ignore these keys and hide them from the user. The type restrictions noted above do not apply.\n\n\nStep 1: Create an item module\n\n\nCreate a new file called \n/your/bundlewrap/repo/items/foo.py\n. You can use this as a template:\n\n\nfrom bundlewrap.items import Item\n\n\nclass Foo(Item):\n    \"\"\"\n    A foo.\n    \"\"\"\n    BUNDLE_ATTRIBUTE_NAME = \"foo\"\n    ITEM_ATTRIBUTES = {\n        'attribute': \"default value\",\n    }\n    ITEM_TYPE_NAME = \"foo\"\n    REQUIRED_ATTRIBUTES = ['attribute']\n\n    @classmethod\n    def block_concurrent(cls, node_os, node_os_version):\n        \"\"\"\n        Return a list of item types that cannot be applied in parallel\n        with this item type.\n        \"\"\"\n        return []\n\n    def __repr__(self):\n        return \"<Foo attribute:{}>\".format(self.attributes['attribute'])\n\n    def cdict(self):\n        \"\"\"\n        Return a statedict that describes the target state of this item\n        as configured in the repo. An empty dict means that the item\n        should not exist.\n\n        Implementing this method is optional. The default implementation\n        uses the attributes as defined in the bundle.\n        \"\"\"\n        raise NotImplementedError\n\n    def sdict(self):\n        \"\"\"\n        Return a statedict that describes the actual state of this item\n        on the node. An empty dict means that the item does not exist\n        on the node.\n\n        For the item to validate as correct, the values for all keys in\n        self.cdict() have to match this statedict.\n        \"\"\"\n        raise NotImplementedError\n\n    def display_dicts(self, cdict, sdict, keys):\n        \"\"\"\n        Given cdict and sdict as implemented above, modify them to\n        better suit interactive presentation. The keys parameter is a\n        list of keys whose values differ between cdict and sdict.\n\n        Implementing this method is optional.\n        \"\"\"\n        return (cdict, sdict, keys)\n\n    def fix(self, status):\n        \"\"\"\n        Do whatever is necessary to correct this item. The given ItemStatus\n        object has the following useful information:\n\n            status.keys     list of cdict keys that need fixing\n            status.cdict    cached copy of self.cdict()\n            status.sdict    cached copy of self.sdict()\n        \"\"\"\n        raise NotImplementedError\n\n\n\n\n\nStep 2: Define attributes\n\n\nBUNDLE_ATTRIBUTE_NAME\n is the name of the variable defined in a bundle module that holds the items of this type. If your bundle looks like this:\n\n\nfoo = { [...] }\n\n\n\n...then you should put \nBUNDLE_ATTRIBUTE_NAME = \"foo\"\n here.\n\n\nITEM_ATTRIBUTES\n is a dictionary of the attributes users will be able to configure for your item. For files, that would be stuff like owner, group, and permissions. Every attribute (even if it's mandatory) needs a default value, \nNone\n is totally acceptable:\n\n\nITEM_ATTRIBUTES = {'attr1': \"default1\"}\n\n\n\nITEM_TYPE_NAME\n sets the first part of an items ID. For the file items, this is \"file\". Therefore, file ID look this this: \nfile:/path\n. The second part is the name a user assigns to your item in a bundle. Example:\n\n\nITEM_TYPE_NAME = \"foo\"\n\n\n\nREQUIRED_ATTRIBUTES\n is a list of attribute names that must be set on each item of this type. If BundleWrap encounters an item without all these attributes during bundle inspection, an exception will be raised. Example:\n\n\nREQUIRED_ATTRIBUTES = ['attr1', 'attr2']\n\n\n\n\n\nStep 3: Implement methods\n\n\nYou should probably start with \nsdict()\n. Use \nself.node.run(\"command\")\n to run shell commands on the current node and check the \nstdout\n property of the returned object.\n\n\nThe only other method you have to implement is \nfix\n. It doesn't have to return anything and just uses \nself.node.run()\n to fix the item. To do this efficiently, it may use the provided parameters indicating which keys differ between the should-be sdict and the actual one. Both sdicts are also provided in case you need to know their values.\n\n\nblock_concurrent()\n must return a list of item types (e.g. \n['pkg_apt']\n) that cannot be applied in parallel with this type of item. May include this very item type itself. For most items this is not an issue (e.g. creating multiple files at the same time), but some types of items have to be applied sequentially (e.g. package managers usually employ locks to ensure only one package is installed at a time).\n\n\nIf you're having trouble, try looking at the \nsource code for the items that come with BundleWrap\n. The \npkg_*\n items are pretty simple and easy to understand while \nfiles\n is the most complex to date. Or just drop by on \nIRC\n, we're glad to help.",
            "title": "Custom items"
        },
        {
            "location": "/guide/dev_item/#custom-item-types",
            "text": "",
            "title": "Custom item types"
        },
        {
            "location": "/guide/dev_item/#step-0-understand-statedicts",
            "text": "To represent supposed vs. actual state, BundleWrap uses statedicts. These are\nnormal Python dictionaries with some restrictions:   keys must be Unicode text  every value must be of one of these simple data types:  bool  float  int  Unicode text  None    ...or a list/tuple containing only instances of one of the types above   Additional information can be stored in statedicts by using keys that start with an underscore. You may only use this for caching purposes (e.g. storing rendered file template content while the \"real\" sdict information only contains a hash of this content). BundleWrap will ignore these keys and hide them from the user. The type restrictions noted above do not apply.",
            "title": "Step 0: Understand statedicts"
        },
        {
            "location": "/guide/dev_item/#step-1-create-an-item-module",
            "text": "Create a new file called  /your/bundlewrap/repo/items/foo.py . You can use this as a template:  from bundlewrap.items import Item\n\n\nclass Foo(Item):\n    \"\"\"\n    A foo.\n    \"\"\"\n    BUNDLE_ATTRIBUTE_NAME = \"foo\"\n    ITEM_ATTRIBUTES = {\n        'attribute': \"default value\",\n    }\n    ITEM_TYPE_NAME = \"foo\"\n    REQUIRED_ATTRIBUTES = ['attribute']\n\n    @classmethod\n    def block_concurrent(cls, node_os, node_os_version):\n        \"\"\"\n        Return a list of item types that cannot be applied in parallel\n        with this item type.\n        \"\"\"\n        return []\n\n    def __repr__(self):\n        return \"<Foo attribute:{}>\".format(self.attributes['attribute'])\n\n    def cdict(self):\n        \"\"\"\n        Return a statedict that describes the target state of this item\n        as configured in the repo. An empty dict means that the item\n        should not exist.\n\n        Implementing this method is optional. The default implementation\n        uses the attributes as defined in the bundle.\n        \"\"\"\n        raise NotImplementedError\n\n    def sdict(self):\n        \"\"\"\n        Return a statedict that describes the actual state of this item\n        on the node. An empty dict means that the item does not exist\n        on the node.\n\n        For the item to validate as correct, the values for all keys in\n        self.cdict() have to match this statedict.\n        \"\"\"\n        raise NotImplementedError\n\n    def display_dicts(self, cdict, sdict, keys):\n        \"\"\"\n        Given cdict and sdict as implemented above, modify them to\n        better suit interactive presentation. The keys parameter is a\n        list of keys whose values differ between cdict and sdict.\n\n        Implementing this method is optional.\n        \"\"\"\n        return (cdict, sdict, keys)\n\n    def fix(self, status):\n        \"\"\"\n        Do whatever is necessary to correct this item. The given ItemStatus\n        object has the following useful information:\n\n            status.keys     list of cdict keys that need fixing\n            status.cdict    cached copy of self.cdict()\n            status.sdict    cached copy of self.sdict()\n        \"\"\"\n        raise NotImplementedError",
            "title": "Step 1: Create an item module"
        },
        {
            "location": "/guide/dev_item/#step-2-define-attributes",
            "text": "BUNDLE_ATTRIBUTE_NAME  is the name of the variable defined in a bundle module that holds the items of this type. If your bundle looks like this:  foo = { [...] }  ...then you should put  BUNDLE_ATTRIBUTE_NAME = \"foo\"  here.  ITEM_ATTRIBUTES  is a dictionary of the attributes users will be able to configure for your item. For files, that would be stuff like owner, group, and permissions. Every attribute (even if it's mandatory) needs a default value,  None  is totally acceptable:  ITEM_ATTRIBUTES = {'attr1': \"default1\"}  ITEM_TYPE_NAME  sets the first part of an items ID. For the file items, this is \"file\". Therefore, file ID look this this:  file:/path . The second part is the name a user assigns to your item in a bundle. Example:  ITEM_TYPE_NAME = \"foo\"  REQUIRED_ATTRIBUTES  is a list of attribute names that must be set on each item of this type. If BundleWrap encounters an item without all these attributes during bundle inspection, an exception will be raised. Example:  REQUIRED_ATTRIBUTES = ['attr1', 'attr2']",
            "title": "Step 2: Define attributes"
        },
        {
            "location": "/guide/dev_item/#step-3-implement-methods",
            "text": "You should probably start with  sdict() . Use  self.node.run(\"command\")  to run shell commands on the current node and check the  stdout  property of the returned object.  The only other method you have to implement is  fix . It doesn't have to return anything and just uses  self.node.run()  to fix the item. To do this efficiently, it may use the provided parameters indicating which keys differ between the should-be sdict and the actual one. Both sdicts are also provided in case you need to know their values.  block_concurrent()  must return a list of item types (e.g.  ['pkg_apt'] ) that cannot be applied in parallel with this type of item. May include this very item type itself. For most items this is not an issue (e.g. creating multiple files at the same time), but some types of items have to be applied sequentially (e.g. package managers usually employ locks to ensure only one package is installed at a time).  If you're having trouble, try looking at the  source code for the items that come with BundleWrap . The  pkg_*  items are pretty simple and easy to understand while  files  is the most complex to date. Or just drop by on  IRC , we're glad to help.",
            "title": "Step 3: Implement methods"
        },
        {
            "location": "/guide/dev_plugin/",
            "text": "Writing your own plugins\n\n\nPlugins\n can provide almost any file in a BundleWrap repository: bundles, custom items, hooks, libs, etc.\n\n\nNotable exceptions are \nnodes.py\n and \ngroups.py\n. If your plugin wants to extend those, use a \nlib\n instead and ask users to add the result of a function call in your lib to their nodes or groups dicts.\n\n\nIf your plugin depends on other libraries, make sure that it catches ImportErrors in a way that makes it obvious for the user what's missing. Keep in mind that people will often just \ngit pull\n their repo and not install your plugin themselves.\n\n\n\n\n\nStarting a new plugin\n\n\nStep 1: Clone the plugins repo\n\n\nCreate a clone of the \nofficial plugins repo\n on GitHub.\n\n\nStep 2: Create a branch\n\n\nYou should work on a branch specific to your plugin.\n\n\nStep 3: Copy your plugin files\n\n\nNow take the files that make up your plugin and move them into a subfolder of the plugins repo. The subfolder must be named like your plugin.\n\n\nStep 4: Create required files\n\n\nIn your plugin subfolder, create a file called \nmanifest.json\n from this template:\n\n\n{\n    \"desc\": \"Concise description (keep it somewhere around 80 characters)\",\n    \"help\": \"Optional verbose help text to be displayed after installing. May\\ninclude\\nnewlines.\",\n    \"provides\": [\n        \"bundles/example/items.py\",\n        \"hooks/example.py\"\n    ],\n    \"version\": 1\n}\n\n\n\nThe \nprovides\n section must contain a list of all files provided by your plugin.\n\n\nYou also have to create an \nAUTHORS\n file containing your name and email address.\n\n\nLast but not least we require a \nLICENSE\n file with an OSI-approved Free Software license.\n\n\nStep 5: Update the plugin index\n\n\nRun the \nupdate_index.py\n script at the root of the plugins repo.\n\n\nStep 6: Run tests\n\n\nRun the \ntest.py\n script at the root of the plugins repo. It will tell you if there is anything wrong with your plugin.\n\n\nStep 7: Commit\n\n\nCommit all changes to your branch\n\n\nStep 8: Create pull request\n\n\nCreate a pull request on GitHub to request inclusion of your new plugin in the official repo. Only then will your plugin become available to be installed by \nbw repo plugin install yourplugin\n.\n\n\n\n\nUpdating an existing plugin\n\n\nTo release a new version of your plugin:\n\n\n\n\nIncrease the version number in \nmanifest.json\n\n\nUpdate the list of provided files in \nmanifest.json\n\n\nIf you're updating someone elses plugin, you should get their consent and add your name to \nAUTHORS\n\n\n\n\nThen just follow the instructions above from step 5 onward.",
            "title": "Writing plugins"
        },
        {
            "location": "/guide/dev_plugin/#writing-your-own-plugins",
            "text": "Plugins  can provide almost any file in a BundleWrap repository: bundles, custom items, hooks, libs, etc.  Notable exceptions are  nodes.py  and  groups.py . If your plugin wants to extend those, use a  lib  instead and ask users to add the result of a function call in your lib to their nodes or groups dicts.  If your plugin depends on other libraries, make sure that it catches ImportErrors in a way that makes it obvious for the user what's missing. Keep in mind that people will often just  git pull  their repo and not install your plugin themselves.",
            "title": "Writing your own plugins"
        },
        {
            "location": "/guide/dev_plugin/#starting-a-new-plugin",
            "text": "",
            "title": "Starting a new plugin"
        },
        {
            "location": "/guide/dev_plugin/#step-1-clone-the-plugins-repo",
            "text": "Create a clone of the  official plugins repo  on GitHub.",
            "title": "Step 1: Clone the plugins repo"
        },
        {
            "location": "/guide/dev_plugin/#step-2-create-a-branch",
            "text": "You should work on a branch specific to your plugin.",
            "title": "Step 2: Create a branch"
        },
        {
            "location": "/guide/dev_plugin/#step-3-copy-your-plugin-files",
            "text": "Now take the files that make up your plugin and move them into a subfolder of the plugins repo. The subfolder must be named like your plugin.",
            "title": "Step 3: Copy your plugin files"
        },
        {
            "location": "/guide/dev_plugin/#step-4-create-required-files",
            "text": "In your plugin subfolder, create a file called  manifest.json  from this template:  {\n    \"desc\": \"Concise description (keep it somewhere around 80 characters)\",\n    \"help\": \"Optional verbose help text to be displayed after installing. May\\ninclude\\nnewlines.\",\n    \"provides\": [\n        \"bundles/example/items.py\",\n        \"hooks/example.py\"\n    ],\n    \"version\": 1\n}  The  provides  section must contain a list of all files provided by your plugin.  You also have to create an  AUTHORS  file containing your name and email address.  Last but not least we require a  LICENSE  file with an OSI-approved Free Software license.",
            "title": "Step 4: Create required files"
        },
        {
            "location": "/guide/dev_plugin/#step-5-update-the-plugin-index",
            "text": "Run the  update_index.py  script at the root of the plugins repo.",
            "title": "Step 5: Update the plugin index"
        },
        {
            "location": "/guide/dev_plugin/#step-6-run-tests",
            "text": "Run the  test.py  script at the root of the plugins repo. It will tell you if there is anything wrong with your plugin.",
            "title": "Step 6: Run tests"
        },
        {
            "location": "/guide/dev_plugin/#step-7-commit",
            "text": "Commit all changes to your branch",
            "title": "Step 7: Commit"
        },
        {
            "location": "/guide/dev_plugin/#step-8-create-pull-request",
            "text": "Create a pull request on GitHub to request inclusion of your new plugin in the official repo. Only then will your plugin become available to be installed by  bw repo plugin install yourplugin .",
            "title": "Step 8: Create pull request"
        },
        {
            "location": "/guide/dev_plugin/#updating-an-existing-plugin",
            "text": "To release a new version of your plugin:   Increase the version number in  manifest.json  Update the list of provided files in  manifest.json  If you're updating someone elses plugin, you should get their consent and add your name to  AUTHORS   Then just follow the instructions above from step 5 onward.",
            "title": "Updating an existing plugin"
        },
        {
            "location": "/guide/api/",
            "text": "API\n\n\nWhile most users will interact with BundleWrap through the \nbw\n command line utility, you can also use it from your own code to extract data or further automate config management tasks.\n\n\nEven within BundleWrap itself (e.g. templates, libs, and hooks) you are often given repo and/or node objects to work with. Their methods and attributes are documented below.\n\n\nSome general notes on using BundleWrap's API:\n\n\n\n\nThere can be an arbitrary amount of \nbundlewrap.repo.Repository\n objects per process.\n\n\nRepositories are read as needed and not re-read when something changes. Modifying files in a repo during the lifetime of the matching Repository object may result in undefined behavior.\n\n\n\n\n\n\nExample\n\n\nHere's a short example of how to use BundleWrap to get the uptime for a node.\n\n\nfrom bundlewrap.repo import Repository\n\nrepo = Repository(\"/path/to/my/repo\")\nnode = repo.get_node(\"mynode\")\nuptime = node.run(\"uptime\")\nprint(uptime.stdout)\n\n\n\n\n\nReference\n\n\nbundlewrap.repo.Repository(path)\n\n\nThe starting point of any interaction with BundleWrap. An object of this class represents the repository at the given path.\n\n\n\n\n.groups\n\n\nA list of all groups in the repo (instances of \nbundlewrap.group.Group\n)\n\n\n\n\n.group_names\n\n\nA list of all group names in this repo.\n\n\n\n\n.nodes\n\n\nA list of all nodes in the repo (instances of \nbundlewrap.node.Node\n)\n\n\n\n\n.node_names\n\n\nA list of all node names in this repo\n\n\n\n\n.revision\n\n\nThe current git, hg or bzr revision of this repo. \nNone\n if no SCM was detected.\n\n\n\n\n.get_group(group_name)\n\n\nReturns the Group object for the given name.\n\n\n\n\n.get_node(node_name)\n\n\nReturns the Node object with the given name.\n\n\n\n\n.nodes_in_all_groups(group_names)\n\n\nReturns a list of Node objects where every node is a member of every group name given.\n\n\n\n\n.nodes_in_any_group(group_names)\n\n\nReturns all Node objects that are a member of at least one of the given group names.\n\n\n\n\n.nodes_in_group(group_name)\n\n\nReturns a list of Node objects in the named group.\n\n\n\n\nbundlewrap.node.Node()\n\n\nA system managed by BundleWrap.\n\n\n\n\n.bundles\n\n\nA list of all bundles associated with this node (instances of \nbundlewrap.bundle.Bundle\n)\n\n\n\n\n.groups\n\n\nA list of \nbundlewrap.group.Group\n objects this node belongs to\n\n\n\n\n.hostname\n\n\nThe DNS name BundleWrap uses to connect to this node\n\n\n\n\n.items\n\n\nA list of items on this node (instances of subclasses of \nbundlewrap.items.Item\n)\n\n\n\n\n.magic_number\n\n\nA large number derived from the node's name. This number is very likely to be unique for your entire repository. You can, for example, use this number to easily \"jitter\" cronjobs:\n\n\n'{} {} * * * root /my/script'.format(\n    node.magic_number % 60,\n    node.magic_number % 2 + 4,\n)\n\n\n\n\n\n.metadata\n\n\nA dictionary of custom metadata, merged from information in \nnodes.py\n and \ngroups.py\n\n\n\n\n.name\n\n\nThe internal identifier for this node\n\n\n\n\n.download(remote_path, local_path)\n\n\nDownloads a file from the node.\n\n\nremote_path\n Which file to get from the node\n\nlocal_path\n Where to put the file\n\n\n\n\n.get_item(item_id)\n\n\nGet the Item object with the given ID (e.g. \"file:/etc/motd\").\n\n\n\n\n.has_bundle(bundle_name)\n\n\nTrue\n if the node has a bundle with the given name.\n\n\n\n\n.has_any_bundle(bundle_names)\n\n\nTrue\n if the node has a bundle with any of the given names.\n\n\n\n\n.in_group(group_name)\n\n\nTrue\n if the node is in a group with the given name.\n\n\n\n\n.in_any_group(group_names)\n\n\nTrue\n if the node is in a group with any of the given names.\n\n\n\n\n.run(command, may_fail=False)\n\n\nRuns a command on the node. Returns an instance of \nbundlewrap.operations.RunResult\n.\n\n\ncommand\n What should be executed on the node\n\nmay_fail\n If \nFalse\n, \nbundlewrap.exceptions.RemoteException\n will be raised if the command does not return 0.\n\n\n\n\n.upload(local_path, remote_path, mode=None, owner=\"\", group=\"\")\n\n\nUploads a file to the node.\n\n\nlocal_path\n Which file to upload\n\nremote_path\n Where to put the file on the target node\n\nmode\n File mode, e.g. \"0644\"\n\nowner\n Username of the file owner\n\ngroup\n Group name of the file group\n\n\n\n\nbundlewrap.group.Group\n\n\nA user-defined group of nodes.\n\n\n\n\n.name\n\n\nThe name of this group\n\n\n\n\n.nodes\n\n\nA list of all nodes in this group (instances of \nbundlewrap.node.Node\n, includes subgroup members)\n\n\n\n\nbundlewrap.utils.Fault\n\n\nA Fault acts as a lazy stand-in object for the result of a given callback function. These objects are returned from the \"vault\" attached to \nRepository\n objects:\n\n\n>>> repo.vault.password_for(\"demo\")\n<bundlewrap.utils.Fault object at 0x10782b208>\n\n\n\nOnly when the \nvalue\n property of a Fault is accessed or when the Fault is converted to a string, the callback function is executed. In the example above, this means that the password is only generated when it is really required (e.g. when used in a template). This is particularly useful when used in metadata in connection with \nsecrets\n. Users will be able to generate metadata with Faults in it, even if they lack the required keys for the decryption operation represented by the Fault. The key will only be required for files etc. that actually use it. If a Fault cannot be resolved (e.g. for lack of the required key), BundleWrap can just skip the item using the Fault, while still allowing other items on the same node to be applied.\n\n\nFaults also support some rudimentary string operations such as appending a string or another Fault, as well as some string methods:\n\n\n>>> f = repo.vault.password_for(\"1\") + \":\" + repo.vault.password_for(\"2\")\n>>> f\n<bundlewrap.utils.Fault object at 0x10782b208>\n>>> f.value\n'VOd5PC:JUgYUb'\n>>> f += \" \"\n>>> f.value\n'VOd5PC:JUgYUb '\n>>> f.strip().value\n'VOd5PC:JUgYUb'\n>>> repo.vault.password_for(\"1\").format_into(\"Password: {}\").value\n'Password: VOd5PC'\n\n\n\nThese string methods are supported on Faults: \nformat\n, \nlower\n, \nlstrip\n, \nreplace\n, \nrstrip\n, \nstrip\n, \nupper\n, \nzfill",
            "title": "Python API"
        },
        {
            "location": "/guide/api/#api",
            "text": "While most users will interact with BundleWrap through the  bw  command line utility, you can also use it from your own code to extract data or further automate config management tasks.  Even within BundleWrap itself (e.g. templates, libs, and hooks) you are often given repo and/or node objects to work with. Their methods and attributes are documented below.  Some general notes on using BundleWrap's API:   There can be an arbitrary amount of  bundlewrap.repo.Repository  objects per process.  Repositories are read as needed and not re-read when something changes. Modifying files in a repo during the lifetime of the matching Repository object may result in undefined behavior.",
            "title": "API"
        },
        {
            "location": "/guide/api/#example",
            "text": "Here's a short example of how to use BundleWrap to get the uptime for a node.  from bundlewrap.repo import Repository\n\nrepo = Repository(\"/path/to/my/repo\")\nnode = repo.get_node(\"mynode\")\nuptime = node.run(\"uptime\")\nprint(uptime.stdout)",
            "title": "Example"
        },
        {
            "location": "/guide/api/#reference",
            "text": "",
            "title": "Reference"
        },
        {
            "location": "/guide/api/#bundlewrapreporepositorypath",
            "text": "The starting point of any interaction with BundleWrap. An object of this class represents the repository at the given path.   .groups  A list of all groups in the repo (instances of  bundlewrap.group.Group )   .group_names  A list of all group names in this repo.   .nodes  A list of all nodes in the repo (instances of  bundlewrap.node.Node )   .node_names  A list of all node names in this repo   .revision  The current git, hg or bzr revision of this repo.  None  if no SCM was detected.   .get_group(group_name)  Returns the Group object for the given name.   .get_node(node_name)  Returns the Node object with the given name.   .nodes_in_all_groups(group_names)  Returns a list of Node objects where every node is a member of every group name given.   .nodes_in_any_group(group_names)  Returns all Node objects that are a member of at least one of the given group names.   .nodes_in_group(group_name)  Returns a list of Node objects in the named group.",
            "title": "bundlewrap.repo.Repository(path)"
        },
        {
            "location": "/guide/api/#bundlewrapnodenode",
            "text": "A system managed by BundleWrap.   .bundles  A list of all bundles associated with this node (instances of  bundlewrap.bundle.Bundle )   .groups  A list of  bundlewrap.group.Group  objects this node belongs to   .hostname  The DNS name BundleWrap uses to connect to this node   .items  A list of items on this node (instances of subclasses of  bundlewrap.items.Item )   .magic_number  A large number derived from the node's name. This number is very likely to be unique for your entire repository. You can, for example, use this number to easily \"jitter\" cronjobs:  '{} {} * * * root /my/script'.format(\n    node.magic_number % 60,\n    node.magic_number % 2 + 4,\n)   .metadata  A dictionary of custom metadata, merged from information in  nodes.py  and  groups.py   .name  The internal identifier for this node   .download(remote_path, local_path)  Downloads a file from the node.  remote_path  Which file to get from the node local_path  Where to put the file   .get_item(item_id)  Get the Item object with the given ID (e.g. \"file:/etc/motd\").   .has_bundle(bundle_name)  True  if the node has a bundle with the given name.   .has_any_bundle(bundle_names)  True  if the node has a bundle with any of the given names.   .in_group(group_name)  True  if the node is in a group with the given name.   .in_any_group(group_names)  True  if the node is in a group with any of the given names.   .run(command, may_fail=False)  Runs a command on the node. Returns an instance of  bundlewrap.operations.RunResult .  command  What should be executed on the node may_fail  If  False ,  bundlewrap.exceptions.RemoteException  will be raised if the command does not return 0.   .upload(local_path, remote_path, mode=None, owner=\"\", group=\"\")  Uploads a file to the node.  local_path  Which file to upload remote_path  Where to put the file on the target node mode  File mode, e.g. \"0644\" owner  Username of the file owner group  Group name of the file group",
            "title": "bundlewrap.node.Node()"
        },
        {
            "location": "/guide/api/#bundlewrapgroupgroup",
            "text": "A user-defined group of nodes.   .name  The name of this group   .nodes  A list of all nodes in this group (instances of  bundlewrap.node.Node , includes subgroup members)",
            "title": "bundlewrap.group.Group"
        },
        {
            "location": "/guide/api/#bundlewraputilsfault",
            "text": "A Fault acts as a lazy stand-in object for the result of a given callback function. These objects are returned from the \"vault\" attached to  Repository  objects:  >>> repo.vault.password_for(\"demo\")\n<bundlewrap.utils.Fault object at 0x10782b208>  Only when the  value  property of a Fault is accessed or when the Fault is converted to a string, the callback function is executed. In the example above, this means that the password is only generated when it is really required (e.g. when used in a template). This is particularly useful when used in metadata in connection with  secrets . Users will be able to generate metadata with Faults in it, even if they lack the required keys for the decryption operation represented by the Fault. The key will only be required for files etc. that actually use it. If a Fault cannot be resolved (e.g. for lack of the required key), BundleWrap can just skip the item using the Fault, while still allowing other items on the same node to be applied.  Faults also support some rudimentary string operations such as appending a string or another Fault, as well as some string methods:  >>> f = repo.vault.password_for(\"1\") + \":\" + repo.vault.password_for(\"2\")\n>>> f\n<bundlewrap.utils.Fault object at 0x10782b208>\n>>> f.value\n'VOd5PC:JUgYUb'\n>>> f += \" \"\n>>> f.value\n'VOd5PC:JUgYUb '\n>>> f.strip().value\n'VOd5PC:JUgYUb'\n>>> repo.vault.password_for(\"1\").format_into(\"Password: {}\").value\n'Password: VOd5PC'  These string methods are supported on Faults:  format ,  lower ,  lstrip ,  replace ,  rstrip ,  strip ,  upper ,  zfill",
            "title": "bundlewrap.utils.Fault"
        },
        {
            "location": "/guide/os_compatibility/",
            "text": "OS compatibility\n\n\nBundleWrap by necessity takes a pragmatic approach to supporting different operating systems and distributions. Our main target is Linux, but support for other UNIXes is also evolving. We cannot guarantee to be compatible with every distribution and BSD flavor under the sun, but we try to cover the common ones.\n\n\n\n\nnode.os and node.os_version\n\n\nYou should set these attributes for every node. Giving BundleWrap this information allows us to adapt some built-in behavior.\n\n\n\n\nother node attributes\n\n\nIn some cases (e.g. when not using sudo) you will need to manually adjust some things. Check the docs \non node-level OS overrides\n.",
            "title": "OS compatibility"
        },
        {
            "location": "/guide/os_compatibility/#os-compatibility",
            "text": "BundleWrap by necessity takes a pragmatic approach to supporting different operating systems and distributions. Our main target is Linux, but support for other UNIXes is also evolving. We cannot guarantee to be compatible with every distribution and BSD flavor under the sun, but we try to cover the common ones.",
            "title": "OS compatibility"
        },
        {
            "location": "/guide/os_compatibility/#nodeos-and-nodeos_version",
            "text": "You should set these attributes for every node. Giving BundleWrap this information allows us to adapt some built-in behavior.",
            "title": "node.os and node.os_version"
        },
        {
            "location": "/guide/os_compatibility/#other-node-attributes",
            "text": "In some cases (e.g. when not using sudo) you will need to manually adjust some things. Check the docs  on node-level OS overrides .",
            "title": "other node attributes"
        },
        {
            "location": "/guide/migrate_12/",
            "text": "Migrating from BundleWrap 1.x to 2.x\n\n\nAs per \nsemver\n, BundleWrap 2.0 breaks compatibility with repositories created for BundleWrap 1.x. This document provides a guide on how to upgrade your repositories to BundleWrap 2.x. Please read the entire document before proceeding. To aid with the transition, BundleWrap 1.6.0 has been released along with 2.0.0. It contains no new features over 1.5.x, but has builtin helpers to aid your migration to 2.0.\n\n\n\n\nitems.py\n\n\nIn every bundle, rename \nbundle.py\n to \nitems.py\n. BundleWrap 1.6.0 can do this for you by running \nbw migrate\n.\n\n\n\n\nDefault file content type\n\n\nThe default \ncontent_type\n for \nfile items\n has changed from \"mako\" to \"text\". This means that you need to check all file items that do not define an explicit content type of \"mako\". Some of them might be fine because you didn't really need templating, while others may need to have their \ncontent_type\n set to \"mako\" explicitly.\n\n\nBundleWrap 1.6.0 will print warnings for every file item affected when running \nbw test\n.\n\n\n\n\nMetadata merging\n\n\nThe merging behavior for node and group metadata has changed. Instead of a simple \ndict.update()\n, metadata dicts are now merged recursively. See \nthe docs\n for details.\n\n\n\n\nMetadata processors and item generators\n\n\nThese two advanced features have been replaced by a single new mechanism: \nmetadata.py\n You will need to rethink and rewrite them.\n\n\nBundleWrap 1.6.0 will print warnings for every group that uses metadata processors and any item generators when running \nbw test\n.\n\n\n\n\nCustom item types\n\n\nThe API for defining your own items has changed. Generally, you should be able to upgrade your items with relatively little effort. Refer to \nthe docs\n for details.\n\n\n\n\nDeterministic templates\n\n\nWhile not a strict requirement, it is highly recommended to ensure your entire configuration can be created deterministically (i.e. remains exactly the same no matter how often you generate it). Otherwise, you won't be able to take advantage of the new functionality provided by \nbw hash\n.\n\n\nA common pitfall here is iteration over dictionaries in templates:\n\n\n% for key, value in my_dict.items():\n${value}\n% endfor\n\n\n\nStandard dictionaries in Python have no defined order. This may result in lines occasionally changing their position. To solve this, you can simply use \nsorted()\n:\n\n\n% for key, value in sorted(my_dict.items()):\n${value}\n% endfor\n\n\n\n\n\nHook arguments\n\n\nSome \nhooks\n had their arguments adjusted slightly.",
            "title": "Migrating to 2.0"
        },
        {
            "location": "/guide/migrate_12/#migrating-from-bundlewrap-1x-to-2x",
            "text": "As per  semver , BundleWrap 2.0 breaks compatibility with repositories created for BundleWrap 1.x. This document provides a guide on how to upgrade your repositories to BundleWrap 2.x. Please read the entire document before proceeding. To aid with the transition, BundleWrap 1.6.0 has been released along with 2.0.0. It contains no new features over 1.5.x, but has builtin helpers to aid your migration to 2.0.",
            "title": "Migrating from BundleWrap 1.x to 2.x"
        },
        {
            "location": "/guide/migrate_12/#itemspy",
            "text": "In every bundle, rename  bundle.py  to  items.py . BundleWrap 1.6.0 can do this for you by running  bw migrate .",
            "title": "items.py"
        },
        {
            "location": "/guide/migrate_12/#default-file-content-type",
            "text": "The default  content_type  for  file items  has changed from \"mako\" to \"text\". This means that you need to check all file items that do not define an explicit content type of \"mako\". Some of them might be fine because you didn't really need templating, while others may need to have their  content_type  set to \"mako\" explicitly.  BundleWrap 1.6.0 will print warnings for every file item affected when running  bw test .",
            "title": "Default file content type"
        },
        {
            "location": "/guide/migrate_12/#metadata-merging",
            "text": "The merging behavior for node and group metadata has changed. Instead of a simple  dict.update() , metadata dicts are now merged recursively. See  the docs  for details.",
            "title": "Metadata merging"
        },
        {
            "location": "/guide/migrate_12/#metadata-processors-and-item-generators",
            "text": "These two advanced features have been replaced by a single new mechanism:  metadata.py  You will need to rethink and rewrite them.  BundleWrap 1.6.0 will print warnings for every group that uses metadata processors and any item generators when running  bw test .",
            "title": "Metadata processors and item generators"
        },
        {
            "location": "/guide/migrate_12/#custom-item-types",
            "text": "The API for defining your own items has changed. Generally, you should be able to upgrade your items with relatively little effort. Refer to  the docs  for details.",
            "title": "Custom item types"
        },
        {
            "location": "/guide/migrate_12/#deterministic-templates",
            "text": "While not a strict requirement, it is highly recommended to ensure your entire configuration can be created deterministically (i.e. remains exactly the same no matter how often you generate it). Otherwise, you won't be able to take advantage of the new functionality provided by  bw hash .  A common pitfall here is iteration over dictionaries in templates:  % for key, value in my_dict.items():\n${value}\n% endfor  Standard dictionaries in Python have no defined order. This may result in lines occasionally changing their position. To solve this, you can simply use  sorted() :  % for key, value in sorted(my_dict.items()):\n${value}\n% endfor",
            "title": "Deterministic templates"
        },
        {
            "location": "/guide/migrate_12/#hook-arguments",
            "text": "Some  hooks  had their arguments adjusted slightly.",
            "title": "Hook arguments"
        },
        {
            "location": "/guide/migrate_23/",
            "text": "Migrating from BundleWrap 2.x to 3.x\n\n\nAs per \nsemver\n, BundleWrap 3.0 breaks compatibility with repositories created for BundleWrap 2.x. This document provides a guide on how to upgrade your repositories to BundleWrap 3.x. Please read the entire document before proceeding.\n\n\n\n\nmetadata.py\n\n\nBundleWrap 2.x simply used all functions in \nmetadata.py\n whose names don't start with an underscore as metadata processors. This led to awkward imports like \nfrom foo import bar as _bar\n. BundleWrap 3.x requires a decorator for explicitly designating functions as metadata processors:\n\n\n@metadata_processor\ndef myproc(metadata):\n    return metadata, DONE\n\n\n\nYou will have to add \n@metadata_processor\n to each metadata processor function. There is no need to import it; it is provided automatically, just like \nnode\n and \nrepo\n.\n\n\nThe accepted return values of metadata processors have changed as well. Metadata processors now always have to return a tuple with the first element being a dictionary of metadata and the remaining elements made up of various options to tell BundleWrap what to do with the dictionary. In most cases, you will want to return the \nDONE\n options as in the example above. There is no need to import options, they're always available.\n\n\nWhen you previously returned \nmetadata, False\n from a metadata processor, you will now have to return \nmetadata, RUN_ME_AGAIN\n. For a more detailed description of the available options, see \nthe documentation\n.\n\n\n\n\nFile and directory ownership defaults\n\n\nFiles\n, \ndirectories\n, and \nsymlinks\n now have default values for the ownership and mode attributes. Previously the default was to ignore them. It's very likely that you won't have to do anything here, just be aware.\n\n\n\n\nsystemd services enabled by default\n\n\nAgain, just be \naware\n, it's probably what you intended anyway.\n\n\n\n\nEnvironment variables\n\n\nThe following \nenv vars\n have been renamed (though the new names have already been available for a while, so chances are you're already using them):\n\n\n\n\nOld\nNew\n\n\nBWADDHOSTKEYS\nBW_ADD_HOST_KEYS\n\n\nBWCOLORS\nBW_COLORS\n\n\nBWITEMWORKERS\nBW_ITEM_WORKERS\n\n\nBWNODEWORKERS\nBW_NODE_WORKERS\n\n\n\n\n\n\n\nItem.display_keys and Item.display_dicts\n\n\nIf you've written your own items and used the \ndisplay_keys()\n or \ndisplay_dicts()\n methods or the \nBLOCK_CONCURRENT\n attribute, you will have to update them to the \nnew API\n.",
            "title": "Migrating to 3.0"
        },
        {
            "location": "/guide/migrate_23/#migrating-from-bundlewrap-2x-to-3x",
            "text": "As per  semver , BundleWrap 3.0 breaks compatibility with repositories created for BundleWrap 2.x. This document provides a guide on how to upgrade your repositories to BundleWrap 3.x. Please read the entire document before proceeding.",
            "title": "Migrating from BundleWrap 2.x to 3.x"
        },
        {
            "location": "/guide/migrate_23/#metadatapy",
            "text": "BundleWrap 2.x simply used all functions in  metadata.py  whose names don't start with an underscore as metadata processors. This led to awkward imports like  from foo import bar as _bar . BundleWrap 3.x requires a decorator for explicitly designating functions as metadata processors:  @metadata_processor\ndef myproc(metadata):\n    return metadata, DONE  You will have to add  @metadata_processor  to each metadata processor function. There is no need to import it; it is provided automatically, just like  node  and  repo .  The accepted return values of metadata processors have changed as well. Metadata processors now always have to return a tuple with the first element being a dictionary of metadata and the remaining elements made up of various options to tell BundleWrap what to do with the dictionary. In most cases, you will want to return the  DONE  options as in the example above. There is no need to import options, they're always available.  When you previously returned  metadata, False  from a metadata processor, you will now have to return  metadata, RUN_ME_AGAIN . For a more detailed description of the available options, see  the documentation .",
            "title": "metadata.py"
        },
        {
            "location": "/guide/migrate_23/#file-and-directory-ownership-defaults",
            "text": "Files ,  directories , and  symlinks  now have default values for the ownership and mode attributes. Previously the default was to ignore them. It's very likely that you won't have to do anything here, just be aware.",
            "title": "File and directory ownership defaults"
        },
        {
            "location": "/guide/migrate_23/#systemd-services-enabled-by-default",
            "text": "Again, just be  aware , it's probably what you intended anyway.",
            "title": "systemd services enabled by default"
        },
        {
            "location": "/guide/migrate_23/#environment-variables",
            "text": "The following  env vars  have been renamed (though the new names have already been available for a while, so chances are you're already using them):   Old New  BWADDHOSTKEYS BW_ADD_HOST_KEYS  BWCOLORS BW_COLORS  BWITEMWORKERS BW_ITEM_WORKERS  BWNODEWORKERS BW_NODE_WORKERS",
            "title": "Environment variables"
        },
        {
            "location": "/guide/migrate_23/#itemdisplay_keys-and-itemdisplay_dicts",
            "text": "If you've written your own items and used the  display_keys()  or  display_dicts()  methods or the  BLOCK_CONCURRENT  attribute, you will have to update them to the  new API .",
            "title": "Item.display_keys and Item.display_dicts"
        },
        {
            "location": "/repo/layout/",
            "text": ".bs-sidebar { display: none; }\n\n\n\nRepository layout\n\n\nA BundleWrap repository contains everything you need to contruct the configuration for your systems.\n\n\nThis page describes the various subdirectories and files than can exist inside a repo.\n\n\n\n\n\n\n\n\nnodes.py\n\n\nThis file tells BundleWrap what nodes (servers, VMs, ...) there are in your environment and lets you configure options such as hostnames.\n\n\n\n\n\n\ngroups.py\n\n\nThis file allows you to organize your nodes into groups.\n\n\n\n\n\n\nbundles/\n\n\nThis required subdirectory contains the bulk of your configuration, organized into bundles of related items.\n\n\n\n\n\n\ndata/\n\n\nThis optional subdirectory contains data files that are not generic enough to be included in bundles (which are meant to be shareable).\n\n\n\n\n\n\nhooks/\n\n\nThis optional subdirectory contains hooks you can use to act on certain events when using BundleWrap.\n\n\n\n\n\n\nitems/\n\n\nThis optional subdirectory contains the code for your custom item types.\n\n\n\n\n\n\nlibs/\n\n\nThis optional subdirectory contains reusable custom code for your bundles.",
            "title": "Overview"
        },
        {
            "location": "/repo/layout/#repository-layout",
            "text": "A BundleWrap repository contains everything you need to contruct the configuration for your systems.  This page describes the various subdirectories and files than can exist inside a repo.     nodes.py  This file tells BundleWrap what nodes (servers, VMs, ...) there are in your environment and lets you configure options such as hostnames.    groups.py  This file allows you to organize your nodes into groups.    bundles/  This required subdirectory contains the bulk of your configuration, organized into bundles of related items.    data/  This optional subdirectory contains data files that are not generic enough to be included in bundles (which are meant to be shareable).    hooks/  This optional subdirectory contains hooks you can use to act on certain events when using BundleWrap.    items/  This optional subdirectory contains the code for your custom item types.    libs/  This optional subdirectory contains reusable custom code for your bundles.",
            "title": "Repository layout"
        },
        {
            "location": "/repo/nodes.py/",
            "text": "nodes.py\n\n\nThis file lets you specify or dynamically build a list of nodes in your environment.\n\n\nAll you have to do here is define a Python dictionary called \nnodes\n. It should look something like this:\n\n\nnodes = {\n    \"node-1\": {\n        'hostname': \"node-1.example.com\",\n    },\n}\n\n\n\nWith BundleWrap, the DNS name and the internal identifier for a node (\"node-1\" in this case) are two separate things.\n\n\nAll fields for a node (including \nhostname\n) are optional. If you don't give one, BundleWrap will attempt to use the internal identifier to connect to a node:\n\n\nnodes = {\n    \"node-1.example.com\": {},\n}\n\n\n\n\n\nDynamic node list\n\n\nYou are not confined to the static way of defining a node list as shown above. You can also assemble the \nnodes\n dictionary dynamically:\n\n\ndef get_my_nodes_from_ldap():\n    [...]\n    return ldap_nodes\n\nnodes = get_my_nodes_from_ldap()\n\n\n\n\n\nOne file per node\n\n\nEspecially in larger installations, a single nodes.py can become inconvenient to work with. This example reads nodes from a \nnodes/\n directory.\n\n\nfrom glob import glob\n\nnodes = {}\nfor node in glob(\"nodes/*.py\"):\n    with open(node, 'r') as f:\n        exec(f.read())\n\n\n\nNode files would then append \nnodes\n, like this:\n\n\n# nodes/node-1.py\nnodes['node-1'] = {\n    'hostname': \"node-1.example.com\",\n}\n\n\n\n\n\nNode attribute reference\n\n\nThis section is a reference for all possible attributes you can define for a node:\n\n\nnodes = {\n    'node-1': {\n        # THIS PART IS EXPLAINED HERE\n    },\n}\n\n\n\nAll attributes can also be set at the group level, unless noted otherwise.\n\n\n\n\nRegular attributes\n\n\nbundles\n\n\nA list of \nbundle names\n to be assigned to this node. Bundles set at \ngroup level\n will be added.\n\n\n\n\ndummy\n\n\nSet this to \nTrue\n to prevent BundleWrap from creating items for and connecting to this node. This is useful for unmanaged nodes because you can still assign them bundles and metadata like regular nodes and access that from managed nodes (e.g. for monitoring).\n\n\n\n\nhostname\n\n\nA string used as a DNS name when connecting to this node. May also be an IP address.\n\n\nThe username and SSH private key for connecting to the node cannot be configured in BundleWrap. If you need to customize those, BundleWrap will honor your \n~/.ssh/config\n.\n\n\n\nCannot be set at group level.\n\n\n\n\nmetadata\n\n\nThis can be a dictionary of arbitrary data (some type restrictions apply). You can access it from your templates as \nnode.metadata\n. Use this to attach custom data (such as a list of IP addresses that should be configured on the target node) to the node. Note that you can also define metadata at the \ngroup level\n, but node metadata has higher priority.\n\n\nYou are restricted to using only the following types in metadata:\n\n\n\n\ndict\n\n\nlist\n\n\ntuple\n\n\nset\n\n\nbool\n\n\ntext\n / \nunicode\n\n\nbytes\n / \nstr\n (only if decodable into text using UTF-8)\n\n\nint\n\n\nNone\n\n\nbundlewrap.utils.Fault\n\n\n\n\nAlso see the \ndocumentation for group.metadata\n for more information.\n\n\n\n\n\nos\n\n\nDefaults to \n\"linux\"\n.\n\n\nA list of supported OSes can be obtained with \nbw debug -n ANY_NODE_NAME -c \"print(node.OS_KNOWN)\"\n.\n\n\n\n\nos_version\n\n\nSet this to your OS version. Note that it must be a tuple of integers, e.g. if you're running Ubuntu 16.04 LTS, it should be \n(16, 4)\n.\n\n\nTuples of integers can be used for easy comparison of versions: \n(12, 4) < (16, 4)\n\n\n\n\nOS compatibility overrides\n\n\ncmd_wrapper_outer\n\n\nUsed whenever a command needs to be run on a node. Defaults to \n\"sudo sh -c {}\"\n. \n{}\n will be replaced by the quoted command to be run (after \ncmd_wrapper_inner\n has been applied).\n\n\nYou will need to override this if you're not using \nsudo\n to gain root privileges (e.g. \ndoas\n) on the node.\n\n\n\n\ncmd_wrapper_inner\n\n\nUsed whenever a command needs to be run on a node. Defaults to \n\"export LANG=C; {}\"\n. \n{}\n will be replaced by the command to be run.\n\n\nYou will need to override this if the shell on your node sets environment variables differently.\n\n\n\n\nuse_shadow_passwords\n\n\nChanging this setting will affect the security of the target system. Only do this for legacy systems that don't support shadow passwords.\n\n\n\nThis setting will affect how the \nuser item\n item operates. If set to \nFalse\n, password hashes will be written directly to \n/etc/passwd\n and thus be accessible to any user on the system. If the OS of the node is set to \"openbsd\", this setting has no effect as \nmaster.shadow\n is always used.",
            "title": "nodes.py"
        },
        {
            "location": "/repo/nodes.py/#nodespy",
            "text": "This file lets you specify or dynamically build a list of nodes in your environment.  All you have to do here is define a Python dictionary called  nodes . It should look something like this:  nodes = {\n    \"node-1\": {\n        'hostname': \"node-1.example.com\",\n    },\n}  With BundleWrap, the DNS name and the internal identifier for a node (\"node-1\" in this case) are two separate things.  All fields for a node (including  hostname ) are optional. If you don't give one, BundleWrap will attempt to use the internal identifier to connect to a node:  nodes = {\n    \"node-1.example.com\": {},\n}",
            "title": "nodes.py"
        },
        {
            "location": "/repo/nodes.py/#dynamic-node-list",
            "text": "You are not confined to the static way of defining a node list as shown above. You can also assemble the  nodes  dictionary dynamically:  def get_my_nodes_from_ldap():\n    [...]\n    return ldap_nodes\n\nnodes = get_my_nodes_from_ldap()",
            "title": "Dynamic node list"
        },
        {
            "location": "/repo/nodes.py/#one-file-per-node",
            "text": "Especially in larger installations, a single nodes.py can become inconvenient to work with. This example reads nodes from a  nodes/  directory.  from glob import glob\n\nnodes = {}\nfor node in glob(\"nodes/*.py\"):\n    with open(node, 'r') as f:\n        exec(f.read())  Node files would then append  nodes , like this:  # nodes/node-1.py\nnodes['node-1'] = {\n    'hostname': \"node-1.example.com\",\n}",
            "title": "One file per node"
        },
        {
            "location": "/repo/nodes.py/#node-attribute-reference",
            "text": "This section is a reference for all possible attributes you can define for a node:  nodes = {\n    'node-1': {\n        # THIS PART IS EXPLAINED HERE\n    },\n}  All attributes can also be set at the group level, unless noted otherwise.",
            "title": "Node attribute reference"
        },
        {
            "location": "/repo/nodes.py/#regular-attributes",
            "text": "",
            "title": "Regular attributes"
        },
        {
            "location": "/repo/nodes.py/#bundles",
            "text": "A list of  bundle names  to be assigned to this node. Bundles set at  group level  will be added.",
            "title": "bundles"
        },
        {
            "location": "/repo/nodes.py/#dummy",
            "text": "Set this to  True  to prevent BundleWrap from creating items for and connecting to this node. This is useful for unmanaged nodes because you can still assign them bundles and metadata like regular nodes and access that from managed nodes (e.g. for monitoring).",
            "title": "dummy"
        },
        {
            "location": "/repo/nodes.py/#hostname",
            "text": "A string used as a DNS name when connecting to this node. May also be an IP address.  The username and SSH private key for connecting to the node cannot be configured in BundleWrap. If you need to customize those, BundleWrap will honor your  ~/.ssh/config .  Cannot be set at group level.",
            "title": "hostname"
        },
        {
            "location": "/repo/nodes.py/#metadata",
            "text": "This can be a dictionary of arbitrary data (some type restrictions apply). You can access it from your templates as  node.metadata . Use this to attach custom data (such as a list of IP addresses that should be configured on the target node) to the node. Note that you can also define metadata at the  group level , but node metadata has higher priority.  You are restricted to using only the following types in metadata:   dict  list  tuple  set  bool  text  /  unicode  bytes  /  str  (only if decodable into text using UTF-8)  int  None  bundlewrap.utils.Fault   Also see the  documentation for group.metadata  for more information.",
            "title": "metadata"
        },
        {
            "location": "/repo/nodes.py/#os",
            "text": "Defaults to  \"linux\" .  A list of supported OSes can be obtained with  bw debug -n ANY_NODE_NAME -c \"print(node.OS_KNOWN)\" .",
            "title": "os"
        },
        {
            "location": "/repo/nodes.py/#os_version",
            "text": "Set this to your OS version. Note that it must be a tuple of integers, e.g. if you're running Ubuntu 16.04 LTS, it should be  (16, 4) .  Tuples of integers can be used for easy comparison of versions:  (12, 4) < (16, 4)",
            "title": "os_version"
        },
        {
            "location": "/repo/nodes.py/#os-compatibility-overrides",
            "text": "",
            "title": "OS compatibility overrides"
        },
        {
            "location": "/repo/nodes.py/#cmd_wrapper_outer",
            "text": "Used whenever a command needs to be run on a node. Defaults to  \"sudo sh -c {}\" .  {}  will be replaced by the quoted command to be run (after  cmd_wrapper_inner  has been applied).  You will need to override this if you're not using  sudo  to gain root privileges (e.g.  doas ) on the node.",
            "title": "cmd_wrapper_outer"
        },
        {
            "location": "/repo/nodes.py/#cmd_wrapper_inner",
            "text": "Used whenever a command needs to be run on a node. Defaults to  \"export LANG=C; {}\" .  {}  will be replaced by the command to be run.  You will need to override this if the shell on your node sets environment variables differently.",
            "title": "cmd_wrapper_inner"
        },
        {
            "location": "/repo/nodes.py/#use_shadow_passwords",
            "text": "Changing this setting will affect the security of the target system. Only do this for legacy systems that don't support shadow passwords.  This setting will affect how the  user item  item operates. If set to  False , password hashes will be written directly to  /etc/passwd  and thus be accessible to any user on the system. If the OS of the node is set to \"openbsd\", this setting has no effect as  master.shadow  is always used.",
            "title": "use_shadow_passwords"
        },
        {
            "location": "/repo/groups.py/",
            "text": "groups.py\n\n\nThis file lets you specify or dynamically build groups of \nnodes\n in your environment.\n\n\nAs with \nnodes.py\n, you define your groups as a dictionary:\n\n\ngroups = {\n    'all': {\n        'member_patterns': (\n            r\".*\",\n        ),\n    },\n    'group1': {\n        'members': (\n            'node1',\n        ),\n    },\n}\n\n\n\nAll group attributes are optional.\n\n\n\n\nGroup attribute reference\n\n\nThis section is a reference for all possible attributes you can define for a group:\n\n\ngroups = {\n     'group1': {\n         # THIS PART IS EXPLAINED HERE\n         'bundles': [\"bundle1\", \"bundle2\"],\n         'members': [\"node1\"],\n         'members_add': lambda node: node.os == 'debian',\n         'members_remove': lambda node: node.os == 'ubuntu',\n         'member_patterns': [r\"^cluster1\\.\"],\n         'metadata': {'foo': \"bar\"},\n         'os': 'linux',\n         'subgroups': [\"group2\", \"group3\"],\n         'subgroup_patterns': [r\"^group.*pattern$\"],\n     },\n}\n\n\n\nNote that many attributes from \nnodes.py\n (e.g. \nbundles\n) may also be set at group level, but aren't explicitly documented here again.\n\n\n\n\nmember_patterns\n\n\nA list of regular expressions. Node names matching these expressions will be added to the group members.\n\n\nMatches are determined using \nthe search() method\n.\n\n\n\n\nmembers\n\n\nA tuple or list of node names that belong to this group.\n\n\n\n\nmembers_add and members_remove\n\n\nFor these attributes you can provide a function that takes a node object as its only argument. The function must return a boolean. The function will be called once for every node in the repo. If \nTrue\n, this node will be added (\nmembers_add\n) to or removed (\nmembers_remove\n) from this group.\n\n\nInside your function you may query node attributes and groups, but you will not see groups or attributes added as a result of a different \nmembers_add\n / \nmembers_remove\n function. Only attributes and groups that have been set statically will be available. You can, however, remove a node with \nmembers_remove\n that you added with \nmembers_add\n (but not vice-versa).\nYou should also avoid using \nnode.metadata\n here. Since metadata ultimately depends on group memberships, only metadata set in \nnodes.py\n will be returned here.\n\n\n\n\n\nmetadata\n\n\nA dictionary that will be accessible from each node's \nnode.metadata\n. For each node, BundleWrap will merge the metadata of all of the node's groups first, then merge in the metadata from the node itself.\n\n\nMetadata is merged recursively by default, meaning nested dicts will overlay each other. Lists will be appended to each other, but not recursed into. In come cases, you want to overwrite instead of merge a piece of metadata. This is accomplished through the use of \nbundlewrap.metadata.atomic()\n and best illustrated as an example:\n\n\nfrom bundlewrap.metadata import atomic\n\ngroups = {\n    'all': {\n        'metadata': {\n            'interfaces': {\n                'eth0': {},\n            },\n            'nameservers': [\"8.8.8.8\", \"8.8.4.4\"],\n            'ntp_servers': [\"pool.ntp.org\"],\n        },\n    },\n    'internal': {\n        'metadata':\n            'interfaces': {\n                'eth1': {},\n            },\n            'nameservers': atomic([\"10.0.0.1\", \"10.0.0.2\"]),\n            'ntp_servers': [\"10.0.0.1\", \"10.0.0.2\"],\n        },\n    },\n}\n\n\n\nA node in both groups will end up with \neth0\n \nand\n \neth1\n.\n\n\nThe nameservers however are overwritten, so that nodes what are in both the \"all\" \nand\n the \"internal\" group will only have the \n10.0.0.x\n ones while nodes just in the \"all\" group will have the \n8.8.x.x\n nameservers.\n\n\nThe NTP servers are appended: a node in both groups will have all three nameservers.\n\n\nBundleWrap will consider group hierarchy when merging metadata. For example, it is possible to define a default nameserver for the \"eu\" group and then override it for the \"eu.frankfurt\" subgroup. The catch is that this only works for groups that are connected through a subgroup hierarchy. Independent groups will have their metadata merged in an undefined order. \nbw test\n will report conflicting metadata in independent groups as a metadata collision.\n\n\n\nAlso see the \ndocumentation for node.metadata\n for more information.\n\n\n\n\n\nsubgroups\n\n\nA tuple or list of group names whose members should be recursively included in this group.\n\n\n\n\nsubgroup_patterns\n\n\nA list of regular expressions. Nodes in with group names matching these expressions will be added to the group members.\n\n\nMatches are determined using \nthe search() method\n.\n\n\n\n\nuse_shadow_passwords\n\n\nSee \nnode attribute documentation\n. May be overridden by subgroups or individual nodes.",
            "title": "groups.py"
        },
        {
            "location": "/repo/groups.py/#groupspy",
            "text": "This file lets you specify or dynamically build groups of  nodes  in your environment.  As with  nodes.py , you define your groups as a dictionary:  groups = {\n    'all': {\n        'member_patterns': (\n            r\".*\",\n        ),\n    },\n    'group1': {\n        'members': (\n            'node1',\n        ),\n    },\n}  All group attributes are optional.",
            "title": "groups.py"
        },
        {
            "location": "/repo/groups.py/#group-attribute-reference",
            "text": "This section is a reference for all possible attributes you can define for a group:  groups = {\n     'group1': {\n         # THIS PART IS EXPLAINED HERE\n         'bundles': [\"bundle1\", \"bundle2\"],\n         'members': [\"node1\"],\n         'members_add': lambda node: node.os == 'debian',\n         'members_remove': lambda node: node.os == 'ubuntu',\n         'member_patterns': [r\"^cluster1\\.\"],\n         'metadata': {'foo': \"bar\"},\n         'os': 'linux',\n         'subgroups': [\"group2\", \"group3\"],\n         'subgroup_patterns': [r\"^group.*pattern$\"],\n     },\n}  Note that many attributes from  nodes.py  (e.g.  bundles ) may also be set at group level, but aren't explicitly documented here again.",
            "title": "Group attribute reference"
        },
        {
            "location": "/repo/groups.py/#member_patterns",
            "text": "A list of regular expressions. Node names matching these expressions will be added to the group members.  Matches are determined using  the search() method .",
            "title": "member_patterns"
        },
        {
            "location": "/repo/groups.py/#members",
            "text": "A tuple or list of node names that belong to this group.",
            "title": "members"
        },
        {
            "location": "/repo/groups.py/#members_add-and-members_remove",
            "text": "For these attributes you can provide a function that takes a node object as its only argument. The function must return a boolean. The function will be called once for every node in the repo. If  True , this node will be added ( members_add ) to or removed ( members_remove ) from this group.  Inside your function you may query node attributes and groups, but you will not see groups or attributes added as a result of a different  members_add  /  members_remove  function. Only attributes and groups that have been set statically will be available. You can, however, remove a node with  members_remove  that you added with  members_add  (but not vice-versa). You should also avoid using  node.metadata  here. Since metadata ultimately depends on group memberships, only metadata set in  nodes.py  will be returned here.",
            "title": "members_add and members_remove"
        },
        {
            "location": "/repo/groups.py/#metadata",
            "text": "A dictionary that will be accessible from each node's  node.metadata . For each node, BundleWrap will merge the metadata of all of the node's groups first, then merge in the metadata from the node itself.  Metadata is merged recursively by default, meaning nested dicts will overlay each other. Lists will be appended to each other, but not recursed into. In come cases, you want to overwrite instead of merge a piece of metadata. This is accomplished through the use of  bundlewrap.metadata.atomic()  and best illustrated as an example:  from bundlewrap.metadata import atomic\n\ngroups = {\n    'all': {\n        'metadata': {\n            'interfaces': {\n                'eth0': {},\n            },\n            'nameservers': [\"8.8.8.8\", \"8.8.4.4\"],\n            'ntp_servers': [\"pool.ntp.org\"],\n        },\n    },\n    'internal': {\n        'metadata':\n            'interfaces': {\n                'eth1': {},\n            },\n            'nameservers': atomic([\"10.0.0.1\", \"10.0.0.2\"]),\n            'ntp_servers': [\"10.0.0.1\", \"10.0.0.2\"],\n        },\n    },\n}  A node in both groups will end up with  eth0   and   eth1 .  The nameservers however are overwritten, so that nodes what are in both the \"all\"  and  the \"internal\" group will only have the  10.0.0.x  ones while nodes just in the \"all\" group will have the  8.8.x.x  nameservers.  The NTP servers are appended: a node in both groups will have all three nameservers.  BundleWrap will consider group hierarchy when merging metadata. For example, it is possible to define a default nameserver for the \"eu\" group and then override it for the \"eu.frankfurt\" subgroup. The catch is that this only works for groups that are connected through a subgroup hierarchy. Independent groups will have their metadata merged in an undefined order.  bw test  will report conflicting metadata in independent groups as a metadata collision.  Also see the  documentation for node.metadata  for more information.",
            "title": "metadata"
        },
        {
            "location": "/repo/groups.py/#subgroups",
            "text": "A tuple or list of group names whose members should be recursively included in this group.",
            "title": "subgroups"
        },
        {
            "location": "/repo/groups.py/#subgroup_patterns",
            "text": "A list of regular expressions. Nodes in with group names matching these expressions will be added to the group members.  Matches are determined using  the search() method .",
            "title": "subgroup_patterns"
        },
        {
            "location": "/repo/groups.py/#use_shadow_passwords",
            "text": "See  node attribute documentation . May be overridden by subgroups or individual nodes.",
            "title": "use_shadow_passwords"
        },
        {
            "location": "/repo/requirements.txt/",
            "text": ".bs-sidebar { display: none; }\n\n\n\nrequirements.txt\n\n\nThis optional file can be used to ensure minimum required versions of BundleWrap and other Python packages on every machine that uses a repository.\n\n\nbw repo create\n will initially add your current version of BundleWrap:\n\n\nbundlewrap>=2.4.0\n\n\n\nYou can add more packages as you like (you do not have to specify a version for each one), just append each package in a separate line. When someone then tries to use your repo without one of those packages, BundleWrap will exit early with a friendly error message:\n\n\n! Python package 'foo' is listed in requirements.txt, but wasn't found. You probably have to install it with `pip install foo`.",
            "title": "requirements.txt"
        },
        {
            "location": "/repo/requirements.txt/#requirementstxt",
            "text": "This optional file can be used to ensure minimum required versions of BundleWrap and other Python packages on every machine that uses a repository.  bw repo create  will initially add your current version of BundleWrap:  bundlewrap>=2.4.0  You can add more packages as you like (you do not have to specify a version for each one), just append each package in a separate line. When someone then tries to use your repo without one of those packages, BundleWrap will exit early with a friendly error message:  ! Python package 'foo' is listed in requirements.txt, but wasn't found. You probably have to install it with `pip install foo`.",
            "title": "requirements.txt"
        },
        {
            "location": "/repo/bundles/",
            "text": "Bundles\n\n\n\nBundles are subdirectories of the \nbundles/\n directory of your BundleWrap repository.\n\n\nitems.py\n\n\nWithin each bundle, there may be a file called \nitems.py\n. It defines any number of magic attributes that are automatically processed by BundleWrap. Each attribute is a dictionary mapping an item name (such as a file name) to a dictionary of attributes (e.g. file ownership information).\n\n\nA typical bundle might look like this:\n\n\nfiles = {\n    '/etc/hosts': {\n         'owner': \"root\",\n         'group': \"root\",\n         'mode': \"0664\",\n         [...]\n    },\n}\n\nusers = {\n    'janedoe': {\n        'home': \"/home/janedoe\",\n        'shell': \"/bin/zsh\",\n        [...]\n    },\n    'johndoe': {\n        'home': \"/home/johndoe\",\n        'shell': \"/bin/bash\",\n        [...]\n    },\n}\n\n\n\nThis bundle defines the attributes \nfiles\n and \nusers\n. Within the \nusers\n attribute, there are two \nuser\n items. Each item maps its name to a dictionary that is understood by the specific kind of item. Below you will find a reference of all builtin item types and the attributes they understand. You can also \ndefine your own item types\n.\n\n\n\n\nItem types\n\n\nThis table lists all item types included in BundleWrap along with the bundle attributes they understand.\n\n\n\n\nType\nBundle attribute\nDescription\n\n\naction\nactions\nActions allow you to run commands on every \nbw apply\n\n\ndirectory\ndirectories\nManages permissions and ownership for directories\n\n\nfile\nfiles\nManages contents, permissions, and ownership for files\n\n\ngroup\ngroups\nManages groups by wrapping \ngroupadd\n, \ngroupmod\n and \ngroupdel\n\n\npkg_apt\npkg_apt\nInstalls and removes packages with APT\n\n\npkg_dnf\npkg_dnf\nInstalls and removes packages with dnf\n\n\npkg_pacman\npkg_pacman\nInstalls and removes packages with pacman\n\n\npkg_pip\npkg_pip\nInstalls and removes Python packages with pip\n\n\npkg_snap\npkg_snap\nInstalls and removes packages with snap\n\n\npkg_yum\npkg_yum\nInstalls and removes packages with yum\n\n\npkg_zypper\npkg_zypper\nInstalls and removes packages with zypper\n\n\npostgres_db\npostgres_dbs\nManages Postgres databases\n\n\npostgres_role\npostgres_roles\nManages Postgres roles\n\n\npkg_pip\npkg_pip\nInstalls and removes Python packages with pip\n\n\npkg_openbsd\npkg_openbsd\nInstalls and removes OpenBSD packages with pkg_add/pkg_delete\n\n\nsvc_openbsd\nsvc_openbsd\nStarts and stops services with OpenBSD's rc\n\n\nsvc_systemd\nsvc_systemd\nStarts and stops services with systemd\n\n\nsvc_systemv\nsvc_systemv\nStarts and stops services with traditional System V init scripts\n\n\nsvc_upstart\nsvc_upstart\nStarts and stops services with Upstart\n\n\nsymlink\nsymlinks\nManages symbolic links and their ownership\n\n\nuser\nusers\nManages users by wrapping \nuseradd\n, \nusermod\n and \nuserdel\n\n\n\n\n\n\n\nBuiltin item attributes\n\n\nThere are also attributes that can be applied to any kind of item.\n\n\n\n\ncomment\n\n\nThis is a string that will be displayed in interactive mode (\nbw apply -i\n) whenever the item is to be changed in any way. You can use it to warn users before they start disruptive actions.\n\n\n\n\nerror_on_missing_fault\n\n\nThis will simply skip an item instead of raising an error when a Fault used for an attribute on the item is unavailable. Faults are special objects used by \nrepo.vault\n to \nhandle secrets\n. A Fault being unavailable can mean you're missing the secret key required to decrypt a secret you're trying to use as an item attribute value.\n\n\nDefaults to \nFalse\n.\n\n\n\n\nneeds\n\n\nOne such attribute is \nneeds\n. It allows for setting up dependencies between items. This is not something you will have to to very often, because there are already implicit dependencies between items types (e.g. all files depend on the users owning them). Here are two examples:\n\n\nmy_items = {\n    'item1': {\n        [...]\n        'needs': [\n            'file:/etc/foo.conf',\n        ],\n    },\n    'item2': {\n        ...\n        'needs': [\n            'pkg_apt:',\n            'bundle:foo',\n        ],\n    }\n}\n\n\n\nThe first item (\nitem1\n, specific attributes have been omitted) depends on a file called \n/etc/foo.conf\n, while \nitem2\n depends on all APT packages being installed and every item in the foo bundle.\n\n\n\n\nneeded_by\n\n\nThis attribute is an alternative way of defining dependencies. It works just like \nneeds\n, but in the other direction. There are only three scenarios where you should use \nneeded_by\n over \nneeds\n:\n\n\n\n\nif you need all items of a certain type to depend on something or\n\n\nif you need all items in a bundle to depend on something or\n\n\nif you need an item in a bundle you can't edit (e.g. because it's provided by a community-maintained \nplugin\n) to depend on something in your bundles\n\n\n\n\n\n\ntags\n\n\nA list of strings to tag an item with. Tagging has no immediate effect in itself, but can be useful in a number of places. For example, you can add dependencies on all items with a given tag:\n\n\npkg_apt = {\n    \"mysql-server-{}\".format(node.metadata.get('mysql_version', \"5.5\")): {\n        'tags': [\"provides-mysqld\"],\n    },\n}\n\nsvc_systemd = {\n    \"myapp\": {\n        'needs': [\"tag:provides-mysqld\"],\n    },\n}\n\n\n\nIn this simplified example we save ourselves from duplicating the logic that gets the current MySQL version from metadata (which is probably overkill here, but you might encounter more complex situations).\n\n\n\n\ntriggers and triggered\n\n\nIn some scenarios, you may want to execute an \naction\n only when an item is fixed (e.g. restart a daemon after a config file has changed or run \npostmap\n after updating an alias file). To do this, BundleWrap has the builtin atttribute \ntriggers\n. You can use it to point to any item that has its \ntriggered\n attribute set to \nTrue\n. Such items will only be checked (or in the case of actions: run) if the triggering item is fixed (or a triggering action completes successfully).\n\n\nfiles = {\n    '/etc/daemon.conf': {\n        [...]\n        'triggers': [\n            'action:restart_daemon',\n        ],\n    },\n}\n\nactions = {\n    'restart_daemon': {\n        'command': \"service daemon restart\",\n        'triggered': True,\n    },\n}\n\n\n\nThe above example will run \nservice daemon restart\n every time BundleWrap successfully applies a change to \n/etc/daemon.conf\n. If an action is triggered multiple times, it will only be run once.\n\n\nSimilar to \nneeded_by\n, \ntriggered_by\n can be used to define a \ntriggers\n relationship from the opposite direction.\n\n\n\n\npreceded_by\n\n\nOperates like \ntriggers\n, but will apply the triggered item \nbefore\n the triggering item. Let's look at an example:\n\n\nfiles = {\n    '/etc/example.conf': {\n        [...]\n        'preceded_by': [\n            'action:backup_example',\n        ],\n    },\n}\n\nactions = {\n    'backup_example': {\n        'command': \"cp /etc/example.conf /etc/example.conf.bak\",\n        'triggered': True,\n    },\n}\n\n\n\nIn this configuration, \n/etc/example.conf\n will always be copied before and only if it is changed. You would probably also want to set \ncascade_skip\n to \nFalse\n on the action so you can skip it in interactive mode when you're sure you don't need the backup copy.\n\n\nSimilar to \nneeded_by\n, \nprecedes\n can be used to define a \npreceded_by\n relationship from the opposite direction.\n\n\n\n\nunless\n\n\nAnother builtin item attribute is \nunless\n. For example, it can be used to construct a one-off file item where BundleWrap will only create the file once, but won't check or modify its contents once it exists.\n\n\nfiles = {\n    \"/path/to/file\": {\n        [...]\n        \"unless\": \"test -x /path/to/file\",\n    },\n}\n\n\n\nThis will run \ntest -x /path/to/file\n before doing anything with the item. If the command returns 0, no action will be taken to \"correct\" the item.\n\n\nAnother common use for \nunless\n is with actions that perform some sort of install operation. In this case, the \nunless\n condition makes sure the install operation is only performed when it is needed instead of every time you run \nbw apply\n. In scenarios like this you will probably want to set \ncascade_skip\n to \nFalse\n so that skipping the installation (because the thing is already installed) will not cause every item that depends on the installed thing to be skipped. Example:\n\n\nactions = {\n    'download_thing': {\n        'command': \"wget http://example.com/thing.bin -O /opt/thing.bin && chmod +x /opt/thing.bin\",\n        'unless': \"test -x /opt/thing.bin\",\n        'cascade_skip': False,\n    },\n    'run_thing': {\n        'command': \"/opt/thing.bin\",\n        'needs': [\"action:download_thing\"],\n    },\n}\n\n\n\nIf \naction:download_thing\n would not set \ncascade_skip\n to \nFalse\n, \naction:run_thing\n would only be executed once: directly after the thing has been downloaded. On subsequent runs, \naction:download_thing\n will fail the \nunless\n condition and be skipped. This would also cause all items that depend on it to be skipped, including \naction:run_thing\n.\n\n\nThe commands you choose for \nunless\n should not change the state of your node. Otherwise, running \nbw verify\n might unexpectedly interfere with your nodes.\n\n\n\n\n\ncascade_skip\n\n\nThere are some situations where you don't want to default behavior of skipping everything that depends on a skipped item. That's where \ncascade_skip\n comes in. Set it to \nFalse\n and skipping an item won't skip those that depend on it. Note that items can be skipped\n\n\n\n\ninteractively or\n\n\nbecause they haven't been triggered or\n\n\nbecause one of their dependencies failed or\n\n\nthey failed their \nunless\n condition or\n\n\nbecause an \naction\n had its \ninteractive\n attribute set to \nTrue\n during a non-interactive run\n\n\n\n\nThe following example will offer to run an \napt-get update\n before installing a package, but continue to install the package even if the update is declined interactively.\n\n\nactions = {\n    'apt_update': {\n        'cascade_skip': False,\n        'command': \"apt-get update\",\n    },\n}\n\npkg_apt = {\n    'somepkg': {\n        'needs': [\"action:apt_update\"],\n    },\n}\n\n\n\ncascade_skip\n defaults to \nTrue\n. However, if the item uses the \nunless\n attribute or is triggered, the default changes to \nFalse\n. Most of the time, this is what you'll want.\n\n\n\n\nCanned actions\n\n\nSome item types have what we call \"canned actions\". Those are pre-defined actions attached directly to an item. Take a look at this example:\n\n\nsvc_upstart = {'mysql': {'running': True}}\n\nfiles = {\n    \"/etc/mysql/my.cnf\": {\n        'source': \"my.cnf\",\n        'triggers': [\n            \"svc_upstart:mysql:reload\",  # this triggers the canned action\n        ],\n    },\n}\n\n\n\nCanned actions always have to be triggered in order to run. In the example above, a change in the file \n/etc/mysql/my.cnf\n will trigger the \nreload\n action defined by the \nsvc_upstart item type\n for the mysql service.\n\n\n\n\nmetadata.py\n\n\nAlongside \nitems.py\n you may create another file called \nmetadata.py\n. It can be used to do advanced processing of the metadata you configured for your nodes and groups. Specifically, it allows each bundle to modify metadata before \nitems.py\n is evaluated.\n\n\nThis is accomplished through metadata processors. Metadata processors are functions that take the metadata dictionary generated so far as their single argument. You must then return a dictionary with any modifications you need to make plus at least one of several options:\n\n\n@metadata_processor\ndef my_metadata_processor(metadata):\n    metadata[\"foo\"] = node.name\n    return metadata, DONE\n\n\n\nYou must always return the modified metadata dictionary as the first element. After that, there are a few options you can return. Every metadata processor from every bundle is called \nrepeatedly\n with the latest metadata dictionary until it indicates that it is done by returning the \nDONE\n option or until \nall\n remaining metadata processors return \nRUN_ME_AGAIN\n. You must always return one of \nDONE\n or \nRUN_ME_AGAIN\n. Use the latter if your metadata processor depends on metadata that is generated by another metadata processor (which may be called after yours). Here is another example:\n\n\n@metadata_processor\ndef first_metadata_processor(metadata):\n    metadata[\"foo\"] = node.name\n    return metadata, DONE\n\n@metadata_processor\ndef second_metadata_processor(metadata):\n    if \"foo\" in metadata:\n        metadata[\"bar\"] = metadata[\"foo\"]\n        return metadata, DONE\n    else:\n        return metadata, RUN_ME_AGAIN\n\n\n\nIn this example, \n\"bar\"\n can only be set once \n\"foo\"\n is available and thus the \nsecond_metadata_processor\n has to wait and request to \nRUN_ME_AGAIN\n until \nfirst_metadata_processor\n ran. This is necessary because the running order of metadata processors is undefined.\n\n\nTo avoid deadlocks when accessing \nother\n nodes' metadata from within a metadata processor, use \nother_node.partial_metadata\n instead of \nother_node.metadata\n. For the same reason, always use the \nmetadata\n parameter to access the current node's metadata, never \nnode.metadata\n.\n\n\n\nAvailable options:\n\n\n\n\nOption\nDescription\n\n\nDONE\nIndicates that this metadata processor has done all it can and need not be called again. Return this whenever possible.\n\n\nRUN_ME_AGAIN\nIndicates that this metadata processor is still waiting for metadata from another metadata processor to become available.\n\n\nDEFAULTS\nThe returned metadata dictionary will only be used to provide default values. The actual metadata generated so far will be recursively merged into the returned dict.\n\n\nOVERWRITE\nThe returned metadata dictionary will be recursively merged into the actual metadata generated so far (inverse of \nDEFAULTS\n).\n\n\n\n\n\nHere is an example of how to use \nDEFAULTS\n:\n\n\n@metadata_processor\ndef my_metadata_processor(metadata):\n    return {\n        \"foo\": {\n            \"bar\": 47,\n        },\n    }, DONE, DEFAULTS\n\n\n\nThis means \nnode.metadata[\"foo\"][\"bar\"]\n will be 47 by default, but can also be overridden in static metadata at the node/group level.\n\n\nFor your convenience, you can access \nrepo\n, \nnode\n, \nmetadata_processor\n and all the options in \nmetadata.py\n without importing them.",
            "title": "bundles/"
        },
        {
            "location": "/repo/bundles/#itemspy",
            "text": "Within each bundle, there may be a file called  items.py . It defines any number of magic attributes that are automatically processed by BundleWrap. Each attribute is a dictionary mapping an item name (such as a file name) to a dictionary of attributes (e.g. file ownership information).  A typical bundle might look like this:  files = {\n    '/etc/hosts': {\n         'owner': \"root\",\n         'group': \"root\",\n         'mode': \"0664\",\n         [...]\n    },\n}\n\nusers = {\n    'janedoe': {\n        'home': \"/home/janedoe\",\n        'shell': \"/bin/zsh\",\n        [...]\n    },\n    'johndoe': {\n        'home': \"/home/johndoe\",\n        'shell': \"/bin/bash\",\n        [...]\n    },\n}  This bundle defines the attributes  files  and  users . Within the  users  attribute, there are two  user  items. Each item maps its name to a dictionary that is understood by the specific kind of item. Below you will find a reference of all builtin item types and the attributes they understand. You can also  define your own item types .",
            "title": "items.py"
        },
        {
            "location": "/repo/bundles/#item-types",
            "text": "This table lists all item types included in BundleWrap along with the bundle attributes they understand.   Type Bundle attribute Description  action actions Actions allow you to run commands on every  bw apply  directory directories Manages permissions and ownership for directories  file files Manages contents, permissions, and ownership for files  group groups Manages groups by wrapping  groupadd ,  groupmod  and  groupdel  pkg_apt pkg_apt Installs and removes packages with APT  pkg_dnf pkg_dnf Installs and removes packages with dnf  pkg_pacman pkg_pacman Installs and removes packages with pacman  pkg_pip pkg_pip Installs and removes Python packages with pip  pkg_snap pkg_snap Installs and removes packages with snap  pkg_yum pkg_yum Installs and removes packages with yum  pkg_zypper pkg_zypper Installs and removes packages with zypper  postgres_db postgres_dbs Manages Postgres databases  postgres_role postgres_roles Manages Postgres roles  pkg_pip pkg_pip Installs and removes Python packages with pip  pkg_openbsd pkg_openbsd Installs and removes OpenBSD packages with pkg_add/pkg_delete  svc_openbsd svc_openbsd Starts and stops services with OpenBSD's rc  svc_systemd svc_systemd Starts and stops services with systemd  svc_systemv svc_systemv Starts and stops services with traditional System V init scripts  svc_upstart svc_upstart Starts and stops services with Upstart  symlink symlinks Manages symbolic links and their ownership  user users Manages users by wrapping  useradd ,  usermod  and  userdel",
            "title": "Item types"
        },
        {
            "location": "/repo/bundles/#builtin-item-attributes",
            "text": "There are also attributes that can be applied to any kind of item.",
            "title": "Builtin item attributes"
        },
        {
            "location": "/repo/bundles/#comment",
            "text": "This is a string that will be displayed in interactive mode ( bw apply -i ) whenever the item is to be changed in any way. You can use it to warn users before they start disruptive actions.",
            "title": "comment"
        },
        {
            "location": "/repo/bundles/#error_on_missing_fault",
            "text": "This will simply skip an item instead of raising an error when a Fault used for an attribute on the item is unavailable. Faults are special objects used by  repo.vault  to  handle secrets . A Fault being unavailable can mean you're missing the secret key required to decrypt a secret you're trying to use as an item attribute value.  Defaults to  False .",
            "title": "error_on_missing_fault"
        },
        {
            "location": "/repo/bundles/#needs",
            "text": "One such attribute is  needs . It allows for setting up dependencies between items. This is not something you will have to to very often, because there are already implicit dependencies between items types (e.g. all files depend on the users owning them). Here are two examples:  my_items = {\n    'item1': {\n        [...]\n        'needs': [\n            'file:/etc/foo.conf',\n        ],\n    },\n    'item2': {\n        ...\n        'needs': [\n            'pkg_apt:',\n            'bundle:foo',\n        ],\n    }\n}  The first item ( item1 , specific attributes have been omitted) depends on a file called  /etc/foo.conf , while  item2  depends on all APT packages being installed and every item in the foo bundle.",
            "title": "needs"
        },
        {
            "location": "/repo/bundles/#needed_by",
            "text": "This attribute is an alternative way of defining dependencies. It works just like  needs , but in the other direction. There are only three scenarios where you should use  needed_by  over  needs :   if you need all items of a certain type to depend on something or  if you need all items in a bundle to depend on something or  if you need an item in a bundle you can't edit (e.g. because it's provided by a community-maintained  plugin ) to depend on something in your bundles",
            "title": "needed_by"
        },
        {
            "location": "/repo/bundles/#tags",
            "text": "A list of strings to tag an item with. Tagging has no immediate effect in itself, but can be useful in a number of places. For example, you can add dependencies on all items with a given tag:  pkg_apt = {\n    \"mysql-server-{}\".format(node.metadata.get('mysql_version', \"5.5\")): {\n        'tags': [\"provides-mysqld\"],\n    },\n}\n\nsvc_systemd = {\n    \"myapp\": {\n        'needs': [\"tag:provides-mysqld\"],\n    },\n}  In this simplified example we save ourselves from duplicating the logic that gets the current MySQL version from metadata (which is probably overkill here, but you might encounter more complex situations).",
            "title": "tags"
        },
        {
            "location": "/repo/bundles/#triggers-and-triggered",
            "text": "In some scenarios, you may want to execute an  action  only when an item is fixed (e.g. restart a daemon after a config file has changed or run  postmap  after updating an alias file). To do this, BundleWrap has the builtin atttribute  triggers . You can use it to point to any item that has its  triggered  attribute set to  True . Such items will only be checked (or in the case of actions: run) if the triggering item is fixed (or a triggering action completes successfully).  files = {\n    '/etc/daemon.conf': {\n        [...]\n        'triggers': [\n            'action:restart_daemon',\n        ],\n    },\n}\n\nactions = {\n    'restart_daemon': {\n        'command': \"service daemon restart\",\n        'triggered': True,\n    },\n}  The above example will run  service daemon restart  every time BundleWrap successfully applies a change to  /etc/daemon.conf . If an action is triggered multiple times, it will only be run once.  Similar to  needed_by ,  triggered_by  can be used to define a  triggers  relationship from the opposite direction.",
            "title": "triggers and triggered"
        },
        {
            "location": "/repo/bundles/#preceded_by",
            "text": "Operates like  triggers , but will apply the triggered item  before  the triggering item. Let's look at an example:  files = {\n    '/etc/example.conf': {\n        [...]\n        'preceded_by': [\n            'action:backup_example',\n        ],\n    },\n}\n\nactions = {\n    'backup_example': {\n        'command': \"cp /etc/example.conf /etc/example.conf.bak\",\n        'triggered': True,\n    },\n}  In this configuration,  /etc/example.conf  will always be copied before and only if it is changed. You would probably also want to set  cascade_skip  to  False  on the action so you can skip it in interactive mode when you're sure you don't need the backup copy.  Similar to  needed_by ,  precedes  can be used to define a  preceded_by  relationship from the opposite direction.",
            "title": "preceded_by"
        },
        {
            "location": "/repo/bundles/#unless",
            "text": "Another builtin item attribute is  unless . For example, it can be used to construct a one-off file item where BundleWrap will only create the file once, but won't check or modify its contents once it exists.  files = {\n    \"/path/to/file\": {\n        [...]\n        \"unless\": \"test -x /path/to/file\",\n    },\n}  This will run  test -x /path/to/file  before doing anything with the item. If the command returns 0, no action will be taken to \"correct\" the item.  Another common use for  unless  is with actions that perform some sort of install operation. In this case, the  unless  condition makes sure the install operation is only performed when it is needed instead of every time you run  bw apply . In scenarios like this you will probably want to set  cascade_skip  to  False  so that skipping the installation (because the thing is already installed) will not cause every item that depends on the installed thing to be skipped. Example:  actions = {\n    'download_thing': {\n        'command': \"wget http://example.com/thing.bin -O /opt/thing.bin && chmod +x /opt/thing.bin\",\n        'unless': \"test -x /opt/thing.bin\",\n        'cascade_skip': False,\n    },\n    'run_thing': {\n        'command': \"/opt/thing.bin\",\n        'needs': [\"action:download_thing\"],\n    },\n}  If  action:download_thing  would not set  cascade_skip  to  False ,  action:run_thing  would only be executed once: directly after the thing has been downloaded. On subsequent runs,  action:download_thing  will fail the  unless  condition and be skipped. This would also cause all items that depend on it to be skipped, including  action:run_thing .  The commands you choose for  unless  should not change the state of your node. Otherwise, running  bw verify  might unexpectedly interfere with your nodes.",
            "title": "unless"
        },
        {
            "location": "/repo/bundles/#cascade_skip",
            "text": "There are some situations where you don't want to default behavior of skipping everything that depends on a skipped item. That's where  cascade_skip  comes in. Set it to  False  and skipping an item won't skip those that depend on it. Note that items can be skipped   interactively or  because they haven't been triggered or  because one of their dependencies failed or  they failed their  unless  condition or  because an  action  had its  interactive  attribute set to  True  during a non-interactive run   The following example will offer to run an  apt-get update  before installing a package, but continue to install the package even if the update is declined interactively.  actions = {\n    'apt_update': {\n        'cascade_skip': False,\n        'command': \"apt-get update\",\n    },\n}\n\npkg_apt = {\n    'somepkg': {\n        'needs': [\"action:apt_update\"],\n    },\n}  cascade_skip  defaults to  True . However, if the item uses the  unless  attribute or is triggered, the default changes to  False . Most of the time, this is what you'll want.",
            "title": "cascade_skip"
        },
        {
            "location": "/repo/bundles/#canned-actions",
            "text": "Some item types have what we call \"canned actions\". Those are pre-defined actions attached directly to an item. Take a look at this example:  svc_upstart = {'mysql': {'running': True}}\n\nfiles = {\n    \"/etc/mysql/my.cnf\": {\n        'source': \"my.cnf\",\n        'triggers': [\n            \"svc_upstart:mysql:reload\",  # this triggers the canned action\n        ],\n    },\n}  Canned actions always have to be triggered in order to run. In the example above, a change in the file  /etc/mysql/my.cnf  will trigger the  reload  action defined by the  svc_upstart item type  for the mysql service.",
            "title": "Canned actions"
        },
        {
            "location": "/repo/bundles/#metadatapy",
            "text": "Alongside  items.py  you may create another file called  metadata.py . It can be used to do advanced processing of the metadata you configured for your nodes and groups. Specifically, it allows each bundle to modify metadata before  items.py  is evaluated.  This is accomplished through metadata processors. Metadata processors are functions that take the metadata dictionary generated so far as their single argument. You must then return a dictionary with any modifications you need to make plus at least one of several options:  @metadata_processor\ndef my_metadata_processor(metadata):\n    metadata[\"foo\"] = node.name\n    return metadata, DONE  You must always return the modified metadata dictionary as the first element. After that, there are a few options you can return. Every metadata processor from every bundle is called  repeatedly  with the latest metadata dictionary until it indicates that it is done by returning the  DONE  option or until  all  remaining metadata processors return  RUN_ME_AGAIN . You must always return one of  DONE  or  RUN_ME_AGAIN . Use the latter if your metadata processor depends on metadata that is generated by another metadata processor (which may be called after yours). Here is another example:  @metadata_processor\ndef first_metadata_processor(metadata):\n    metadata[\"foo\"] = node.name\n    return metadata, DONE\n\n@metadata_processor\ndef second_metadata_processor(metadata):\n    if \"foo\" in metadata:\n        metadata[\"bar\"] = metadata[\"foo\"]\n        return metadata, DONE\n    else:\n        return metadata, RUN_ME_AGAIN  In this example,  \"bar\"  can only be set once  \"foo\"  is available and thus the  second_metadata_processor  has to wait and request to  RUN_ME_AGAIN  until  first_metadata_processor  ran. This is necessary because the running order of metadata processors is undefined.  To avoid deadlocks when accessing  other  nodes' metadata from within a metadata processor, use  other_node.partial_metadata  instead of  other_node.metadata . For the same reason, always use the  metadata  parameter to access the current node's metadata, never  node.metadata .  Available options:   Option Description  DONE Indicates that this metadata processor has done all it can and need not be called again. Return this whenever possible.  RUN_ME_AGAIN Indicates that this metadata processor is still waiting for metadata from another metadata processor to become available.  DEFAULTS The returned metadata dictionary will only be used to provide default values. The actual metadata generated so far will be recursively merged into the returned dict.  OVERWRITE The returned metadata dictionary will be recursively merged into the actual metadata generated so far (inverse of  DEFAULTS ).   Here is an example of how to use  DEFAULTS :  @metadata_processor\ndef my_metadata_processor(metadata):\n    return {\n        \"foo\": {\n            \"bar\": 47,\n        },\n    }, DONE, DEFAULTS  This means  node.metadata[\"foo\"][\"bar\"]  will be 47 by default, but can also be overridden in static metadata at the node/group level.  For your convenience, you can access  repo ,  node ,  metadata_processor  and all the options in  metadata.py  without importing them.",
            "title": "metadata.py"
        },
        {
            "location": "/repo/hooks/",
            "text": "Hooks\n\n\nHooks enable you to execute custom code at certain points during a BundleWrap run. This is useful for integrating with other systems e.g. for team notifications, logging or statistics.\n\n\nTo use hooks, you need to create a subdirectory in your repo called \nhooks\n. In that directory you can place an arbitrary number of Python source files. If those source files define certain functions, these functions will be called at the appropriate time.\n\n\nExample\n\n\nhooks/my_awesome_notification.py\n:\n\n\nfrom my_awesome_notification_system import post_message\n\ndef node_apply_start(repo, node, interactive=False, **kwargs):\n    post_message(\"Starting apply on {}, everything is gonna be OK!\".format(node.name))\n\n\n\nAlways define your hooks with \n**kwargs\n so we can pass in more information in future updates without breaking your hook.\n\n\n\n\n\nFunctions\n\n\nThis is a list of all functions a hook file may implement.\n\n\n\n\naction_run_start(repo, node, item, **kwargs)\n\n\nCalled each time a \nbw apply\n command reaches a new action.\n\n\nrepo\n The current repository (instance of \nbundlewrap.repo.Repository\n).\n\n\nnode\n The current node (instance of \nbundlewrap.node.Node\n).\n\n\nitem\n The current action.\n\n\n\n\naction_run_end(repo, node, item, duration=None, status=None, **kwargs)\n\n\nCalled each time a \nbw apply\n command completes processing an action.\n\n\nrepo\n The current repository (instance of \nbundlewrap.repo.Repository\n).\n\n\nnode\n The current node (instance of \nbundlewrap.node.Node\n).\n\n\nitem\n The current action.\n\n\nduration\n How long the action was running (timedelta).\n\n\nstatus\n: One of \nbundlewrap.items.Item.STATUS_FAILED\n, \nbundlewrap.items.Item.STATUS_SKIPPED\n, or \nbundlewrap.items.Item.STATUS_ACTION_SUCCEEDED\n.\n\n\n\n\napply_start(repo, target, nodes, interactive=False, **kwargs)\n\n\nCalled when you start a \nbw apply\n command.\n\n\nrepo\n The current repository (instance of \nbundlewrap.repo.Repository\n).\n\n\ntarget\n The group or node name you gave on the command line.\n\n\nnodes\n A list of node objects affected (list of \nbundlewrap.node.Node\n instances).\n\n\ninteractive\n Indicates whether the apply is interactive or not.\n\n\n\n\napply_end(repo, target, nodes, duration=None, **kwargs)\n\n\nCalled when a \nbw apply\n command completes.\n\n\nrepo\n The current repository (instance of \nbundlewrap.repo.Repository\n).\n\n\ntarget\n The group or node name you gave on the command line.\n\n\nnodes\n A list of node objects affected (list of \nbundlewrap.node.Node\n instances).\n\n\nduration\n How long the apply took (timedelta).\n\n\n\n\nitem_apply_start(repo, node, item, **kwargs)\n\n\nCalled each time a \nbw apply\n command reaches a new item.\n\n\nrepo\n The current repository (instance of \nbundlewrap.repo.Repository\n).\n\n\nnode\n The current node (instance of \nbundlewrap.node.Node\n).\n\n\nitem\n The current item.\n\n\n\n\nitem_apply_end(repo, node, item, duration=None, status_code=None, status_before=None, status_after=None, **kwargs)\n\n\nCalled each time a \nbw apply\n command completes processing an item.\n\n\nrepo\n The current repository (instance of \nbundlewrap.repo.Repository\n).\n\n\nnode\n The current node (instance of \nbundlewrap.node.Node\n).\n\n\nitem\n The current item.\n\n\nduration\n How long the apply took (timedelta).\n\n\nstatus_code\n One of \nbundlewrap.items.Item.STATUS_FAILED\n, \nbundlewrap.items.Item.STATUS_SKIPPED\n, \nbundlewrap.items.Item.STATUS_OK\n, or \nbundlewrap.items.Item.STATUS_FIXED\n.\n\n\nstatus_before\n An instance of \nbundlewrap.items.ItemStatus\n.\n\n\nstatus_after\n See \nstatus_before\n.\n\n\n\n\nlock_add(repo, node, lock_id, items, expiry, comment, **kwargs)\n\n\nCalled each time a soft lock is added to a node.\n\n\nrepo\n The current repository (instance of \nbundlewrap.repo.Repository\n).\n\n\nnode\n The current node (instance of \nbundlewrap.node.Node\n).\n\n\nlock_id\n The random ID of the lock.\n\n\nitems\n List of item selector strings.\n\n\nexpiry\n UNIX timestamp of lock expiry time (int).\n\n\ncomment\n As entered by user.\n\n\n\n\nlock_remove(repo, node, lock_id, **kwargs)\n\n\nCalled each time a soft lock is removed from a node.\n\n\nrepo\n The current repository (instance of \nbundlewrap.repo.Repository\n).\n\n\nnode\n The current node (instance of \nbundlewrap.node.Node\n).\n\n\nlock_id\n The random ID of the lock.\n\n\n\n\nlock_show(repo, node, lock_info, **kwargs)\n\n\nCalled each time \nbw lock show\n finds a lock on a node.\n\n\nrepo\n The current repository (instance of \nbundlewrap.repo.Repository\n).\n\n\nnode\n The current node (instance of \nbundlewrap.node.Node\n).\n\n\nlock_info\n A dict contain the lock details.\n\n\n\n\nnode_apply_start(repo, node, interactive=False, **kwargs)\n\n\nCalled each time a \nbw apply\n command reaches a new node.\n\n\nrepo\n The current repository (instance of \nbundlewrap.repo.Repository\n).\n\n\nnode\n The current node (instance of \nbundlewrap.node.Node\n).\n\n\ninteractive\n \nTrue\n if this is an interactive apply run.\n\n\n\n\nnode_apply_end(repo, node, duration=None, interactive=False, result=None, **kwargs)\n\n\nCalled each time a \nbw apply\n command finishes processing a node.\n\n\nrepo\n The current repository (instance of \nbundlewrap.repo.Repository\n).\n\n\nnode\n The current node (instance of \nbundlewrap.node.Node\n).\n\n\nduration\n How long the apply took (timedelta).\n\n\ninteractive\n \nTrue\n if this was an interactive apply run.\n\n\nresult: An instance of\nbundlewrap.node.ApplyResult`.\n\n\n\n\nnode_run_start(repo, node, command, **kwargs)\n\n\nCalled each time a \nbw run\n command reaches a new node.\n\n\nrepo\n The current repository (instance of \nbundlewrap.repo.Repository\n).\n\n\nnode\n The current node (instance of \nbundlewrap.node.Node\n).\n\n\ncommand\n The command that will be run on the node.\n\n\n\n\nnode_run_end(repo, node, command, duration=None, return_code=None, stdout=\"\", stderr=\"\", **kwargs)\n\n\nCalled each time a \nbw run\n command finishes on a node.\n\n\nrepo\n The current repository (instance of \nbundlewrap.repo.Repository\n).\n\n\nnode\n The current node (instance of \nbundlewrap.node.Node\n).\n\n\ncommand\n The command that was run on the node.\n\n\nduration\n How long it took to run the command (timedelta).\n\n\nreturn_code\n Return code of the remote command.\n\n\nstdout\n The captured stdout stream of the remote command.\n\n\nstderr\n The captured stderr stream of the remote command.\n\n\n\n\nrun_start(repo, target, nodes, command, **kwargs)\n\n\nCalled each time a \nbw run\n command starts.\n\n\nrepo\n The current repository (instance of \nbundlewrap.repo.Repository\n).\n\n\ntarget\n The group or node name you gave on the command line.\n\n\nnodes\n A list of node objects affected (list of \nbundlewrap.node.Node\n instances).\n\n\ncommand\n The command that will be run on the node.\n\n\n\n\nrun_end(repo, target, nodes, command, duration=None, **kwargs)\n\n\nCalled each time a \nbw run\n command finishes.\n\n\nrepo\n The current repository (instance of \nbundlewrap.repo.Repository\n).\n\n\ntarget\n The group or node name you gave on the command line.\n\n\nnodes\n A list of node objects affected (list of \nbundlewrap.node.Node\n instances).\n\n\ncommand\n The command that was run.\n\n\nduration\n How long it took to run the command on all nodes (timedelta).\n\n\n\n\ntest(repo, **kwargs)\n\n\nCalled at the end of a full \nbw test\n.\n\n\nrepo\n The current repository (instance of \nbundlewrap.repo.Repository\n).\n\n\n\n\ntest_node(repo, node, **kwargs)\n\n\nCalled during \nbw test\n for each node.\n\n\nrepo\n The current repository (instance of \nbundlewrap.repo.Repository\n).\n\n\nnode\n The current node (instance of \nbundlewrap.node.Node\n).",
            "title": "hooks/"
        },
        {
            "location": "/repo/hooks/#hooks",
            "text": "Hooks enable you to execute custom code at certain points during a BundleWrap run. This is useful for integrating with other systems e.g. for team notifications, logging or statistics.  To use hooks, you need to create a subdirectory in your repo called  hooks . In that directory you can place an arbitrary number of Python source files. If those source files define certain functions, these functions will be called at the appropriate time.",
            "title": "Hooks"
        },
        {
            "location": "/repo/hooks/#example",
            "text": "hooks/my_awesome_notification.py :  from my_awesome_notification_system import post_message\n\ndef node_apply_start(repo, node, interactive=False, **kwargs):\n    post_message(\"Starting apply on {}, everything is gonna be OK!\".format(node.name))  Always define your hooks with  **kwargs  so we can pass in more information in future updates without breaking your hook.",
            "title": "Example"
        },
        {
            "location": "/repo/hooks/#functions",
            "text": "This is a list of all functions a hook file may implement.   action_run_start(repo, node, item, **kwargs)  Called each time a  bw apply  command reaches a new action.  repo  The current repository (instance of  bundlewrap.repo.Repository ).  node  The current node (instance of  bundlewrap.node.Node ).  item  The current action.   action_run_end(repo, node, item, duration=None, status=None, **kwargs)  Called each time a  bw apply  command completes processing an action.  repo  The current repository (instance of  bundlewrap.repo.Repository ).  node  The current node (instance of  bundlewrap.node.Node ).  item  The current action.  duration  How long the action was running (timedelta).  status : One of  bundlewrap.items.Item.STATUS_FAILED ,  bundlewrap.items.Item.STATUS_SKIPPED , or  bundlewrap.items.Item.STATUS_ACTION_SUCCEEDED .   apply_start(repo, target, nodes, interactive=False, **kwargs)  Called when you start a  bw apply  command.  repo  The current repository (instance of  bundlewrap.repo.Repository ).  target  The group or node name you gave on the command line.  nodes  A list of node objects affected (list of  bundlewrap.node.Node  instances).  interactive  Indicates whether the apply is interactive or not.   apply_end(repo, target, nodes, duration=None, **kwargs)  Called when a  bw apply  command completes.  repo  The current repository (instance of  bundlewrap.repo.Repository ).  target  The group or node name you gave on the command line.  nodes  A list of node objects affected (list of  bundlewrap.node.Node  instances).  duration  How long the apply took (timedelta).   item_apply_start(repo, node, item, **kwargs)  Called each time a  bw apply  command reaches a new item.  repo  The current repository (instance of  bundlewrap.repo.Repository ).  node  The current node (instance of  bundlewrap.node.Node ).  item  The current item.   item_apply_end(repo, node, item, duration=None, status_code=None, status_before=None, status_after=None, **kwargs)  Called each time a  bw apply  command completes processing an item.  repo  The current repository (instance of  bundlewrap.repo.Repository ).  node  The current node (instance of  bundlewrap.node.Node ).  item  The current item.  duration  How long the apply took (timedelta).  status_code  One of  bundlewrap.items.Item.STATUS_FAILED ,  bundlewrap.items.Item.STATUS_SKIPPED ,  bundlewrap.items.Item.STATUS_OK , or  bundlewrap.items.Item.STATUS_FIXED .  status_before  An instance of  bundlewrap.items.ItemStatus .  status_after  See  status_before .   lock_add(repo, node, lock_id, items, expiry, comment, **kwargs)  Called each time a soft lock is added to a node.  repo  The current repository (instance of  bundlewrap.repo.Repository ).  node  The current node (instance of  bundlewrap.node.Node ).  lock_id  The random ID of the lock.  items  List of item selector strings.  expiry  UNIX timestamp of lock expiry time (int).  comment  As entered by user.   lock_remove(repo, node, lock_id, **kwargs)  Called each time a soft lock is removed from a node.  repo  The current repository (instance of  bundlewrap.repo.Repository ).  node  The current node (instance of  bundlewrap.node.Node ).  lock_id  The random ID of the lock.   lock_show(repo, node, lock_info, **kwargs)  Called each time  bw lock show  finds a lock on a node.  repo  The current repository (instance of  bundlewrap.repo.Repository ).  node  The current node (instance of  bundlewrap.node.Node ).  lock_info  A dict contain the lock details.   node_apply_start(repo, node, interactive=False, **kwargs)  Called each time a  bw apply  command reaches a new node.  repo  The current repository (instance of  bundlewrap.repo.Repository ).  node  The current node (instance of  bundlewrap.node.Node ).  interactive   True  if this is an interactive apply run.   node_apply_end(repo, node, duration=None, interactive=False, result=None, **kwargs)  Called each time a  bw apply  command finishes processing a node.  repo  The current repository (instance of  bundlewrap.repo.Repository ).  node  The current node (instance of  bundlewrap.node.Node ).  duration  How long the apply took (timedelta).  interactive   True  if this was an interactive apply run.  result: An instance of bundlewrap.node.ApplyResult`.   node_run_start(repo, node, command, **kwargs)  Called each time a  bw run  command reaches a new node.  repo  The current repository (instance of  bundlewrap.repo.Repository ).  node  The current node (instance of  bundlewrap.node.Node ).  command  The command that will be run on the node.   node_run_end(repo, node, command, duration=None, return_code=None, stdout=\"\", stderr=\"\", **kwargs)  Called each time a  bw run  command finishes on a node.  repo  The current repository (instance of  bundlewrap.repo.Repository ).  node  The current node (instance of  bundlewrap.node.Node ).  command  The command that was run on the node.  duration  How long it took to run the command (timedelta).  return_code  Return code of the remote command.  stdout  The captured stdout stream of the remote command.  stderr  The captured stderr stream of the remote command.   run_start(repo, target, nodes, command, **kwargs)  Called each time a  bw run  command starts.  repo  The current repository (instance of  bundlewrap.repo.Repository ).  target  The group or node name you gave on the command line.  nodes  A list of node objects affected (list of  bundlewrap.node.Node  instances).  command  The command that will be run on the node.   run_end(repo, target, nodes, command, duration=None, **kwargs)  Called each time a  bw run  command finishes.  repo  The current repository (instance of  bundlewrap.repo.Repository ).  target  The group or node name you gave on the command line.  nodes  A list of node objects affected (list of  bundlewrap.node.Node  instances).  command  The command that was run.  duration  How long it took to run the command on all nodes (timedelta).   test(repo, **kwargs)  Called at the end of a full  bw test .  repo  The current repository (instance of  bundlewrap.repo.Repository ).   test_node(repo, node, **kwargs)  Called during  bw test  for each node.  repo  The current repository (instance of  bundlewrap.repo.Repository ).  node  The current node (instance of  bundlewrap.node.Node ).",
            "title": "Functions"
        },
        {
            "location": "/repo/libs/",
            "text": ".bs-sidebar { display: none; }\n\n\n\nCustom code\n\n\nThe \nlibs/\n subdirectory of your repository provides a convenient place to put reusable code used throughout your bundles and hooks.\n\n\nA Python module called \nexample.py\n placed in this directory will be available as \nrepo.libs.example\n wherever you have access to a \nbundlewrap.repo.Repository\n object. In \nnodes.py\n and \ngroups.py\n, you can do the same thing with just \nlibs.example\n.\n\n\nOnly single files, no subdirectories or packages, are supported at the moment.",
            "title": "libs/"
        },
        {
            "location": "/repo/libs/#custom-code",
            "text": "The  libs/  subdirectory of your repository provides a convenient place to put reusable code used throughout your bundles and hooks.  A Python module called  example.py  placed in this directory will be available as  repo.libs.example  wherever you have access to a  bundlewrap.repo.Repository  object. In  nodes.py  and  groups.py , you can do the same thing with just  libs.example .  Only single files, no subdirectories or packages, are supported at the moment.",
            "title": "Custom code"
        },
        {
            "location": "/repo/plugins/",
            "text": "Plugins\n\n\nThe plugin system in BundleWrap is an easy way of integrating third-party code into your repository.\n\n\nWhile plugins are subject to some superficial code review by BundleWrap developers before being accepted, we cannot make any guarantees as to the quality and trustworthiness of plugins. Always do your due diligence before running third-party code.\n\n\n\n\n\nFinding plugins\n\n\nIt's as easy as \nbw repo plugin search <term>\n. Or you can browse \nplugins.bundlewrap.org\n.\n\n\n\n\nInstalling plugins\n\n\nYou probably guessed it: \nbw repo plugin install <plugin>\n\n\nInstalling the first plugin in your repo will create a file called \nplugins.json\n. You should commit this file (and any files installed by the plugin of course) to version control.\n\n\nAvoid editing files provided by plugins at all costs. Local modifications will prevent future updates to the plugin.\n\n\n\n\n\nUpdating plugins\n\n\nYou can update all installed plugins with this command: \nbw repo plugin update\n\n\n\n\nRemoving a plugin\n\n\nbw repo plugin remove <plugin>\n\n\n\n\nWriting your own\n\n\nSee the \nguide on publishing your own plugins\n.",
            "title": "Plugins"
        },
        {
            "location": "/repo/plugins/#plugins",
            "text": "The plugin system in BundleWrap is an easy way of integrating third-party code into your repository.  While plugins are subject to some superficial code review by BundleWrap developers before being accepted, we cannot make any guarantees as to the quality and trustworthiness of plugins. Always do your due diligence before running third-party code.",
            "title": "Plugins"
        },
        {
            "location": "/repo/plugins/#finding-plugins",
            "text": "It's as easy as  bw repo plugin search <term> . Or you can browse  plugins.bundlewrap.org .",
            "title": "Finding plugins"
        },
        {
            "location": "/repo/plugins/#installing-plugins",
            "text": "You probably guessed it:  bw repo plugin install <plugin>  Installing the first plugin in your repo will create a file called  plugins.json . You should commit this file (and any files installed by the plugin of course) to version control.  Avoid editing files provided by plugins at all costs. Local modifications will prevent future updates to the plugin.",
            "title": "Installing plugins"
        },
        {
            "location": "/repo/plugins/#updating-plugins",
            "text": "You can update all installed plugins with this command:  bw repo plugin update",
            "title": "Updating plugins"
        },
        {
            "location": "/repo/plugins/#removing-a-plugin",
            "text": "bw repo plugin remove <plugin>",
            "title": "Removing a plugin"
        },
        {
            "location": "/repo/plugins/#writing-your-own",
            "text": "See the  guide on publishing your own plugins .",
            "title": "Writing your own"
        },
        {
            "location": "/items/action/",
            "text": "Actions\n\n\nActions will be run on every \nbw apply\n. They differ from regular items in that they cannot be \"correct\" in the first place. They can only succeed or fail.\n\n\nactions = {\n    'check_if_its_still_linux': {\n        'command': \"uname\",\n        'expected_return_code': 0,\n        'expected_stdout': \"Linux\\n\",\n    },\n}\n\n\n\n\n\nAttribute reference\n\n\nSee also: \nThe list of generic builtin item attributes\n\n\n\n\ncommand\n\n\nThe only required attribute. This is the command that will be run on the node with root privileges.\n\n\n\n\ndata_stdin\n\n\nYou can pipe data directly to the command running on the node. To do so, use this attribute. If it's a string or unicode object, it will always be encoded as UTF-8. Alternatively, you can use raw bytes.\n\n\n\n\nexpected_return_code\n\n\nDefaults to \n0\n. If the return code of your command is anything else, the action is considered failed. You can also set this to \nNone\n and any return code will be accepted.\n\n\n\n\nexpected_stdout\n\n\nIf this is given, the stdout output of the command must match the given string or the action is considered failed.\n\n\n\n\nexpected_stderr\n\n\nSame as \nexpected_stdout\n, but with stderr.\n\n\n\n\ninteractive\n\n\nIf set to \nTrue\n, this action will be skipped in non-interactive mode. If set to \nFalse\n, this action will always be executed without asking (even in interactive mode). Defaults to \nNone\n.\n\n\nThink hard before setting this to \nFalse\n. People might assume that interactive mode won't do anything without their consent.",
            "title": "action"
        },
        {
            "location": "/items/action/#actions",
            "text": "Actions will be run on every  bw apply . They differ from regular items in that they cannot be \"correct\" in the first place. They can only succeed or fail.  actions = {\n    'check_if_its_still_linux': {\n        'command': \"uname\",\n        'expected_return_code': 0,\n        'expected_stdout': \"Linux\\n\",\n    },\n}",
            "title": "Actions"
        },
        {
            "location": "/items/action/#attribute-reference",
            "text": "See also:  The list of generic builtin item attributes",
            "title": "Attribute reference"
        },
        {
            "location": "/items/action/#command",
            "text": "The only required attribute. This is the command that will be run on the node with root privileges.",
            "title": "command"
        },
        {
            "location": "/items/action/#data_stdin",
            "text": "You can pipe data directly to the command running on the node. To do so, use this attribute. If it's a string or unicode object, it will always be encoded as UTF-8. Alternatively, you can use raw bytes.",
            "title": "data_stdin"
        },
        {
            "location": "/items/action/#expected_return_code",
            "text": "Defaults to  0 . If the return code of your command is anything else, the action is considered failed. You can also set this to  None  and any return code will be accepted.",
            "title": "expected_return_code"
        },
        {
            "location": "/items/action/#expected_stdout",
            "text": "If this is given, the stdout output of the command must match the given string or the action is considered failed.",
            "title": "expected_stdout"
        },
        {
            "location": "/items/action/#expected_stderr",
            "text": "Same as  expected_stdout , but with stderr.",
            "title": "expected_stderr"
        },
        {
            "location": "/items/action/#interactive",
            "text": "If set to  True , this action will be skipped in non-interactive mode. If set to  False , this action will always be executed without asking (even in interactive mode). Defaults to  None .  Think hard before setting this to  False . People might assume that interactive mode won't do anything without their consent.",
            "title": "interactive"
        },
        {
            "location": "/items/directory/",
            "text": "Directory items\n\n\ndirectories = {\n    \"/path/to/directory\": {\n        \"mode\": \"0755\",\n        \"owner\": \"root\",\n        \"group\": \"root\",\n    },\n}\n\n\n\nAttribute reference\n\n\nSee also: \nThe list of generic builtin item attributes\n\n\n\n\ngroup\n\n\nName of the group this directory belongs to. Defaults to \n'root'\n. Set to \nNone\n if you don't want BundleWrap to change whatever is set on the node.\n\n\n\n\nmode\n\n\nDirectory mode as returned by \nstat -c %a <directory>\n. Defaults to \n755\n. Set to \nNone\n if you don't want BundleWrap to change whatever is set on the node.\n\n\n\n\nowner\n\n\nUsername of the directory's owner. Defaults to \n'root'\n. Set to \nNone\n if you don't want BundleWrap to change whatever is set on the node.\n\n\n\n\npurge\n\n\nSet this to \nTrue\n to remove everything from this directory that is not managed by BundleWrap. Defaults to \nFalse\n.",
            "title": "directory"
        },
        {
            "location": "/items/directory/#directory-items",
            "text": "directories = {\n    \"/path/to/directory\": {\n        \"mode\": \"0755\",\n        \"owner\": \"root\",\n        \"group\": \"root\",\n    },\n}",
            "title": "Directory items"
        },
        {
            "location": "/items/directory/#attribute-reference",
            "text": "See also:  The list of generic builtin item attributes",
            "title": "Attribute reference"
        },
        {
            "location": "/items/directory/#group",
            "text": "Name of the group this directory belongs to. Defaults to  'root' . Set to  None  if you don't want BundleWrap to change whatever is set on the node.",
            "title": "group"
        },
        {
            "location": "/items/directory/#mode",
            "text": "Directory mode as returned by  stat -c %a <directory> . Defaults to  755 . Set to  None  if you don't want BundleWrap to change whatever is set on the node.",
            "title": "mode"
        },
        {
            "location": "/items/directory/#owner",
            "text": "Username of the directory's owner. Defaults to  'root' . Set to  None  if you don't want BundleWrap to change whatever is set on the node.",
            "title": "owner"
        },
        {
            "location": "/items/directory/#purge",
            "text": "Set this to  True  to remove everything from this directory that is not managed by BundleWrap. Defaults to  False .",
            "title": "purge"
        },
        {
            "location": "/items/file/",
            "text": "File items\n\n\nManage regular files.\n\n\nfiles = {\n    \"/path/to/file\": {\n        \"mode\": \"0644\",\n        \"owner\": \"root\",\n        \"group\": \"root\",\n        \"content_type\": \"mako\",\n        \"encoding\": \"utf-8\",\n        \"source\": \"my_template\",\n    },\n}\n\n\n\n\n\nAttribute reference\n\n\nSee also: \nThe list of generic builtin item attributes\n\n\n\n\ncontent\n\n\nMay be used instead of \nsource\n to provide file content without a template file.\n\n\n\n\ncontent_type\n\n\nHow the file pointed to by \nsource\n or the string given to \ncontent\n should be interpreted.\n\n\n\n\nValue\nEffect\n\n\nany\nonly cares about file owner, group, and mode\n\n\nbase64\ncontent is decoded from base64\n\n\nbinary\nfile is uploaded verbatim, no content processing occurs\n\n\njinja2\ncontent is interpreted by the Jinja2 template engine\n\n\nmako\ncontent is interpreted by the Mako template engine\n\n\ntext\n (default)\nlike \nbinary\n, but will be diffed in interactive mode\n\n\n\n\n\n\n\ncontext\n\n\nOnly used with Mako and Jinja2 templates. The values of this dictionary will be available from within the template as variables named after the respective keys.\n\n\n\n\ndelete\n\n\nWhen set to \nTrue\n, the path of this file will be removed. It doesn't matter if there is not a file but a directory or something else at this path. When using \ndelete\n, no other attributes are allowed.\n\n\n\n\nencoding\n\n\nEncoding of the target file. Note that this applies to the remote file only, your template is still conveniently written in UTF-8 and will be converted by BundleWrap. Defaults to \"utf-8\". Other possible values (e.g. \"latin-1\") can be found \nhere\n.\n\n\n\n\ngroup\n\n\nName of the group this file belongs to. Defaults to \n'root'\n. Set to \nNone\n if you don't want BundleWrap to change whatever is set on the node.\n\n\n\n\nmode\n\n\nFile mode as returned by \nstat -c %a <file>\n. Defaults to \n644\n. Set to \nNone\n if you don't want BundleWrap to change whatever is set on the node.\n\n\n\n\nowner\n\n\nUsername of the file's owner. Defaults to \n'root'\n. Set to \nNone\n if you don't want BundleWrap to change whatever is set on the node.\n\n\n\n\nsource\n\n\nFile name of the file template. If this says \nmy_template\n, BundleWrap will look in \ndata/my_bundle/files/my_template\n and then \nbundles/my_bundle/files/my_template\n. Most of the time, you will want to put config templates into the latter directory. The \ndata/\n subdirectory is meant for files that are very specific to your infrastructure (e.g. DNS zone files). This separation allows you to write your bundles in a generic way so that they could be open-sourced and shared with other people. Defaults to the filename of this item (e.g. \nfoo.conf\n when this item is \n/etc/foo.conf\n).\n\n\nSee also: \nWriting file templates\n\n\n\n\nverify_with\n\n\nThis can be used to run external validation commands on a file before it is applied to a node. The file is verified locally on the machine running BundleWrap. Verification is considered successful when the exit code of the verification command is 0. Use \n{}\n as a placeholder for the shell-quoted path to the temporary file. Here is an example for verifying sudoers files:\n\n\nvisudo -cf {}\n\n\n\nKeep in mind that all team members will have to have the verification command installed on their machines.",
            "title": "file"
        },
        {
            "location": "/items/file/#file-items",
            "text": "Manage regular files.  files = {\n    \"/path/to/file\": {\n        \"mode\": \"0644\",\n        \"owner\": \"root\",\n        \"group\": \"root\",\n        \"content_type\": \"mako\",\n        \"encoding\": \"utf-8\",\n        \"source\": \"my_template\",\n    },\n}",
            "title": "File items"
        },
        {
            "location": "/items/file/#attribute-reference",
            "text": "See also:  The list of generic builtin item attributes",
            "title": "Attribute reference"
        },
        {
            "location": "/items/file/#content",
            "text": "May be used instead of  source  to provide file content without a template file.",
            "title": "content"
        },
        {
            "location": "/items/file/#content_type",
            "text": "How the file pointed to by  source  or the string given to  content  should be interpreted.   Value Effect  any only cares about file owner, group, and mode  base64 content is decoded from base64  binary file is uploaded verbatim, no content processing occurs  jinja2 content is interpreted by the Jinja2 template engine  mako content is interpreted by the Mako template engine  text  (default) like  binary , but will be diffed in interactive mode",
            "title": "content_type"
        },
        {
            "location": "/items/file/#context",
            "text": "Only used with Mako and Jinja2 templates. The values of this dictionary will be available from within the template as variables named after the respective keys.",
            "title": "context"
        },
        {
            "location": "/items/file/#delete",
            "text": "When set to  True , the path of this file will be removed. It doesn't matter if there is not a file but a directory or something else at this path. When using  delete , no other attributes are allowed.",
            "title": "delete"
        },
        {
            "location": "/items/file/#encoding",
            "text": "Encoding of the target file. Note that this applies to the remote file only, your template is still conveniently written in UTF-8 and will be converted by BundleWrap. Defaults to \"utf-8\". Other possible values (e.g. \"latin-1\") can be found  here .",
            "title": "encoding"
        },
        {
            "location": "/items/file/#group",
            "text": "Name of the group this file belongs to. Defaults to  'root' . Set to  None  if you don't want BundleWrap to change whatever is set on the node.",
            "title": "group"
        },
        {
            "location": "/items/file/#mode",
            "text": "File mode as returned by  stat -c %a <file> . Defaults to  644 . Set to  None  if you don't want BundleWrap to change whatever is set on the node.",
            "title": "mode"
        },
        {
            "location": "/items/file/#owner",
            "text": "Username of the file's owner. Defaults to  'root' . Set to  None  if you don't want BundleWrap to change whatever is set on the node.",
            "title": "owner"
        },
        {
            "location": "/items/file/#source",
            "text": "File name of the file template. If this says  my_template , BundleWrap will look in  data/my_bundle/files/my_template  and then  bundles/my_bundle/files/my_template . Most of the time, you will want to put config templates into the latter directory. The  data/  subdirectory is meant for files that are very specific to your infrastructure (e.g. DNS zone files). This separation allows you to write your bundles in a generic way so that they could be open-sourced and shared with other people. Defaults to the filename of this item (e.g.  foo.conf  when this item is  /etc/foo.conf ).  See also:  Writing file templates",
            "title": "source"
        },
        {
            "location": "/items/file/#verify_with",
            "text": "This can be used to run external validation commands on a file before it is applied to a node. The file is verified locally on the machine running BundleWrap. Verification is considered successful when the exit code of the verification command is 0. Use  {}  as a placeholder for the shell-quoted path to the temporary file. Here is an example for verifying sudoers files:  visudo -cf {}  Keep in mind that all team members will have to have the verification command installed on their machines.",
            "title": "verify_with"
        },
        {
            "location": "/items/group/",
            "text": "Group items\n\n\nManages system groups. Group members are managed through the \nuser item\n.\n\n\ngroups = {\n    \"acme\": {\n        \"gid\": 2342,\n    },\n}\n\n\n\n\n\nAttribute reference\n\n\nSee also: \nThe list of generic builtin item attributes\n\n\n\n\ndelete\n\n\nWhen set to \nTrue\n, this group will be removed from the system. When using \ndelete\n, no other attributes are allowed.\n\n\n\n\ngid\n\n\nNumerical ID of the group.",
            "title": "group"
        },
        {
            "location": "/items/group/#group-items",
            "text": "Manages system groups. Group members are managed through the  user item .  groups = {\n    \"acme\": {\n        \"gid\": 2342,\n    },\n}",
            "title": "Group items"
        },
        {
            "location": "/items/group/#attribute-reference",
            "text": "See also:  The list of generic builtin item attributes",
            "title": "Attribute reference"
        },
        {
            "location": "/items/group/#delete",
            "text": "When set to  True , this group will be removed from the system. When using  delete , no other attributes are allowed.",
            "title": "delete"
        },
        {
            "location": "/items/group/#gid",
            "text": "Numerical ID of the group.",
            "title": "gid"
        },
        {
            "location": "/items/pkg_apt/",
            "text": "APT package items\n\n\nHandles packages installed by \napt-get\n on Debian-based systems.\n\n\npkg_apt = {\n    \"foopkg\": {\n        \"installed\": True,  # default\n    },\n    \"bar_i386\": {  # i386 multiarch variant of the \"bar\" package\n        \"installed\": False,\n    },\n    \"awesome-daemon\": {\n        \"when_creating\": {\n            \"start_service\": False,\n        },\n    },\n}\n\n\n\n\n\nAttribute reference\n\n\nSee also: \nThe list of generic builtin item attributes\n\n\n\n\ninstalled\n\n\nTrue\n when the package is expected to be present on the system; \nFalse\n if it should be purged.\n\n\nwhen_creating\n\n\nThese attributes are only enforced during the creation of the item on the node (in this case this means when a package is installed). They are ignored in subsequent runs of \nbw apply\n.\n\n\nstart_service\n\n\nBy default, daemons will be auto-started on systems like Debian or Ubuntu. This happens right after the package has been installed. You might want to set \nstart_service\n to \nFalse\n to avoid this. This might be necessary if BundleWrap must place some more config files on the node before a daemon can actually be started.",
            "title": "pkg_apt"
        },
        {
            "location": "/items/pkg_apt/#apt-package-items",
            "text": "Handles packages installed by  apt-get  on Debian-based systems.  pkg_apt = {\n    \"foopkg\": {\n        \"installed\": True,  # default\n    },\n    \"bar_i386\": {  # i386 multiarch variant of the \"bar\" package\n        \"installed\": False,\n    },\n    \"awesome-daemon\": {\n        \"when_creating\": {\n            \"start_service\": False,\n        },\n    },\n}",
            "title": "APT package items"
        },
        {
            "location": "/items/pkg_apt/#attribute-reference",
            "text": "See also:  The list of generic builtin item attributes",
            "title": "Attribute reference"
        },
        {
            "location": "/items/pkg_apt/#installed",
            "text": "True  when the package is expected to be present on the system;  False  if it should be purged.",
            "title": "installed"
        },
        {
            "location": "/items/pkg_apt/#when95creating",
            "text": "These attributes are only enforced during the creation of the item on the node (in this case this means when a package is installed). They are ignored in subsequent runs of  bw apply .",
            "title": "when_creating"
        },
        {
            "location": "/items/pkg_apt/#start95service",
            "text": "By default, daemons will be auto-started on systems like Debian or Ubuntu. This happens right after the package has been installed. You might want to set  start_service  to  False  to avoid this. This might be necessary if BundleWrap must place some more config files on the node before a daemon can actually be started.",
            "title": "start_service"
        },
        {
            "location": "/items/pkg_dnf/",
            "text": "dnf package items\n\n\nHandles packages installed by \ndnf\n on RPM-based systems.\n\n\npkg_dnf = {\n    \"foopkg\": {\n        \"installed\": True,  # default\n    },\n    \"bar\": {\n        \"installed\": False,\n    },\n}\n\n\n\n\n\nAttribute reference\n\n\nSee also: \nThe list of generic builtin item attributes\n\n\n\n\ninstalled\n\n\nTrue\n when the package is expected to be present on the system; \nFalse\n if it should be removed.",
            "title": "pkg_dnf"
        },
        {
            "location": "/items/pkg_dnf/#dnf-package-items",
            "text": "Handles packages installed by  dnf  on RPM-based systems.  pkg_dnf = {\n    \"foopkg\": {\n        \"installed\": True,  # default\n    },\n    \"bar\": {\n        \"installed\": False,\n    },\n}",
            "title": "dnf package items"
        },
        {
            "location": "/items/pkg_dnf/#attribute-reference",
            "text": "See also:  The list of generic builtin item attributes",
            "title": "Attribute reference"
        },
        {
            "location": "/items/pkg_dnf/#installed",
            "text": "True  when the package is expected to be present on the system;  False  if it should be removed.",
            "title": "installed"
        },
        {
            "location": "/items/pkg_pacman/",
            "text": "Pacman package items\n\n\nHandles packages installed by \npacman\n (e.g. Arch Linux).\n\n\npkg_pacman = {\n    \"foopkg\": {\n        \"installed\": True,  # default\n    },\n    \"bar\": {\n        \"installed\": False,\n    },\n    \"somethingelse\": {\n        \"tarball\": \"something-1.0.pkg.tar.gz\",\n    }\n}\n\n\n\nSystem updates on Arch Linux should \nalways\n be performed manually and with great care. Thus, this item type installs packages with a simple \npacman -S $pkgname\n instead of the commonly recommended \npacman -Syu $pkgname\n. You should \nmanually\n do a full system update before installing new packages via BundleWrap!\n\n\n\n\n\nAttribute reference\n\n\nSee also: \nThe list of generic builtin item attributes\n\n\n\n\ninstalled\n\n\nTrue\n when the package is expected to be present on the system; \nFalse\n if this package and all dependencies that are no longer needed should be removed.\n\n\n\n\ntarball\n\n\nUpload a local file to the node and install it using \npacman -U\n. The value of \ntarball\n must point to a file relative to the \npkg_pacman\n subdirectory of the current bundle.",
            "title": "pkg_pacman"
        },
        {
            "location": "/items/pkg_pacman/#pacman-package-items",
            "text": "Handles packages installed by  pacman  (e.g. Arch Linux).  pkg_pacman = {\n    \"foopkg\": {\n        \"installed\": True,  # default\n    },\n    \"bar\": {\n        \"installed\": False,\n    },\n    \"somethingelse\": {\n        \"tarball\": \"something-1.0.pkg.tar.gz\",\n    }\n}  System updates on Arch Linux should  always  be performed manually and with great care. Thus, this item type installs packages with a simple  pacman -S $pkgname  instead of the commonly recommended  pacman -Syu $pkgname . You should  manually  do a full system update before installing new packages via BundleWrap!",
            "title": "Pacman package items"
        },
        {
            "location": "/items/pkg_pacman/#attribute-reference",
            "text": "See also:  The list of generic builtin item attributes",
            "title": "Attribute reference"
        },
        {
            "location": "/items/pkg_pacman/#installed",
            "text": "True  when the package is expected to be present on the system;  False  if this package and all dependencies that are no longer needed should be removed.",
            "title": "installed"
        },
        {
            "location": "/items/pkg_pacman/#tarball",
            "text": "Upload a local file to the node and install it using  pacman -U . The value of  tarball  must point to a file relative to the  pkg_pacman  subdirectory of the current bundle.",
            "title": "tarball"
        },
        {
            "location": "/items/pkg_pip/",
            "text": "pip package items\n\n\nHandles Python packages installed by \npip\n.\n\n\npkg_pip = {\n    \"foo\": {\n        \"installed\": True,  # default\n        \"version\": \"1.0\",  # optional\n    },\n    \"bar\": {\n        \"installed\": False,\n    },\n    \"/path/to/virtualenv/foo\": {\n        # will install foo in the virtualenv at /path/to/virtualenv\n    },\n}\n\n\n\n\n\nAttribute reference\n\n\nSee also: \nThe list of generic builtin item attributes\n\n\n\n\ninstalled\n\n\nTrue\n when the package is expected to be present on the system; \nFalse\n if it should be removed.\n\n\n\n\nversion\n\n\nForce the given exact version to be installed. You can only specify a single version here, selectors like \n>=1.0\n are NOT supported.\n\n\nIf it's not given, the latest version will be installed initially, but (like the other package items) upgrades will NOT be installed.",
            "title": "pkg_pip"
        },
        {
            "location": "/items/pkg_pip/#pip-package-items",
            "text": "Handles Python packages installed by  pip .  pkg_pip = {\n    \"foo\": {\n        \"installed\": True,  # default\n        \"version\": \"1.0\",  # optional\n    },\n    \"bar\": {\n        \"installed\": False,\n    },\n    \"/path/to/virtualenv/foo\": {\n        # will install foo in the virtualenv at /path/to/virtualenv\n    },\n}",
            "title": "pip package items"
        },
        {
            "location": "/items/pkg_pip/#attribute-reference",
            "text": "See also:  The list of generic builtin item attributes",
            "title": "Attribute reference"
        },
        {
            "location": "/items/pkg_pip/#installed",
            "text": "True  when the package is expected to be present on the system;  False  if it should be removed.",
            "title": "installed"
        },
        {
            "location": "/items/pkg_pip/#version",
            "text": "Force the given exact version to be installed. You can only specify a single version here, selectors like  >=1.0  are NOT supported.  If it's not given, the latest version will be installed initially, but (like the other package items) upgrades will NOT be installed.",
            "title": "version"
        },
        {
            "location": "/items/pkg_snap/",
            "text": "snap package items\n\n\nHandles packages installed by \nsnap\n command.\n\n\npkg_snap = {\n    \"foopkg\": {\n        \"installed\": True,  # default\n    },\n    \"bar\": {\n        \"installed\": False,\n    },\n}\n\n\n\n\n\nAttribute reference\n\n\nSee also: \nThe list of generic builtin item attributes\n\n\n\n\ninstalled\n\n\nTrue\n when the package is expected to be present on the system; \nFalse\n if it should be removed.",
            "title": "pkg_snap"
        },
        {
            "location": "/items/pkg_snap/#snap-package-items",
            "text": "Handles packages installed by  snap  command.  pkg_snap = {\n    \"foopkg\": {\n        \"installed\": True,  # default\n    },\n    \"bar\": {\n        \"installed\": False,\n    },\n}",
            "title": "snap package items"
        },
        {
            "location": "/items/pkg_snap/#attribute-reference",
            "text": "See also:  The list of generic builtin item attributes",
            "title": "Attribute reference"
        },
        {
            "location": "/items/pkg_snap/#installed",
            "text": "True  when the package is expected to be present on the system;  False  if it should be removed.",
            "title": "installed"
        },
        {
            "location": "/items/pkg_yum/",
            "text": "yum package items\n\n\nHandles packages installed by \nyum\n on RPM-based systems.\n\n\npkg_yum = {\n    \"foopkg\": {\n        \"installed\": True,  # default\n    },\n    \"bar\": {\n        \"installed\": False,\n    },\n}\n\n\n\n\n\nAttribute reference\n\n\nSee also: \nThe list of generic builtin item attributes\n\n\n\n\ninstalled\n\n\nTrue\n when the package is expected to be present on the system; \nFalse\n if it should be removed.",
            "title": "pkg_yum"
        },
        {
            "location": "/items/pkg_yum/#yum-package-items",
            "text": "Handles packages installed by  yum  on RPM-based systems.  pkg_yum = {\n    \"foopkg\": {\n        \"installed\": True,  # default\n    },\n    \"bar\": {\n        \"installed\": False,\n    },\n}",
            "title": "yum package items"
        },
        {
            "location": "/items/pkg_yum/#attribute-reference",
            "text": "See also:  The list of generic builtin item attributes",
            "title": "Attribute reference"
        },
        {
            "location": "/items/pkg_yum/#installed",
            "text": "True  when the package is expected to be present on the system;  False  if it should be removed.",
            "title": "installed"
        },
        {
            "location": "/items/pkg_zypper/",
            "text": "zypper package items\n\n\nHandles packages installed by \nzypper\n on SUSE-based systems.\n\n\npkg_zypper = {\n    \"foopkg\": {\n        \"installed\": True,  # default\n    },\n    \"bar\": {\n        \"installed\": False,\n    },\n}\n\n\n\n\n\nAttribute reference\n\n\nSee also: \nThe list of generic builtin item attributes\n\n\n\n\ninstalled\n\n\nTrue\n when the package is expected to be present on the system; \nFalse\n if it should be removed.",
            "title": "pkg_zypper"
        },
        {
            "location": "/items/pkg_zypper/#zypper-package-items",
            "text": "Handles packages installed by  zypper  on SUSE-based systems.  pkg_zypper = {\n    \"foopkg\": {\n        \"installed\": True,  # default\n    },\n    \"bar\": {\n        \"installed\": False,\n    },\n}",
            "title": "zypper package items"
        },
        {
            "location": "/items/pkg_zypper/#attribute-reference",
            "text": "See also:  The list of generic builtin item attributes",
            "title": "Attribute reference"
        },
        {
            "location": "/items/pkg_zypper/#installed",
            "text": "True  when the package is expected to be present on the system;  False  if it should be removed.",
            "title": "installed"
        },
        {
            "location": "/items/postgres_db/",
            "text": "Postgres database items\n\n\nManages Postgres databases.\n\n\npostgres_dbs = {\n    \"mydatabase\": {\n        \"owner\": \"me\",\n        \"when_creating\": {\n            \"encoding\": \"LATIN1\",\n            \"collation\": \"de_DE.ISO-8859-1\",\n            \"ctype\": \"de_DE.ISO-8859-1\",\n        },\n    },\n}\n\n\n\n\n\nAttribute reference\n\n\nSee also: \nThe list of generic builtin item attributes\n\n\n\n\nowner\n\n\nName of the role which owns this database (defaults to \n\"postgres\"\n).\n\n\nencoding, collation, and ctype\n\n\nBy default, BundleWrap will only create a database using your default PostgreSQL template, which most likely is \ntemplate1\n. This means it will use the same encoding and collation that \ntemplate1\n uses. By specifying any of the attributes \nencoding\n, \ncollation\n, or \nctype\n, BundleWrap will instead create a new database from \ntemplate0\n, thus allowing you to override said database attributes.\n\n\nThese options are creation-time only.",
            "title": "postgres_db"
        },
        {
            "location": "/items/postgres_db/#postgres-database-items",
            "text": "Manages Postgres databases.  postgres_dbs = {\n    \"mydatabase\": {\n        \"owner\": \"me\",\n        \"when_creating\": {\n            \"encoding\": \"LATIN1\",\n            \"collation\": \"de_DE.ISO-8859-1\",\n            \"ctype\": \"de_DE.ISO-8859-1\",\n        },\n    },\n}",
            "title": "Postgres database items"
        },
        {
            "location": "/items/postgres_db/#attribute-reference",
            "text": "See also:  The list of generic builtin item attributes",
            "title": "Attribute reference"
        },
        {
            "location": "/items/postgres_db/#owner",
            "text": "Name of the role which owns this database (defaults to  \"postgres\" ).",
            "title": "owner"
        },
        {
            "location": "/items/postgres_db/#encoding-collation-and-ctype",
            "text": "By default, BundleWrap will only create a database using your default PostgreSQL template, which most likely is  template1 . This means it will use the same encoding and collation that  template1  uses. By specifying any of the attributes  encoding ,  collation , or  ctype , BundleWrap will instead create a new database from  template0 , thus allowing you to override said database attributes.  These options are creation-time only.",
            "title": "encoding, collation, and ctype"
        },
        {
            "location": "/items/postgres_role/",
            "text": "Postgres role items\n\n\nManages Postgres roles.\n\n\npostgres_roles = {\n    \"me\": {\n        \"superuser\": True,\n        \"password\": \"itsamemario\",\n    },\n}\n\n\n\n\n\nAttribute reference\n\n\nSee also: \nThe list of generic builtin item attributes\n\n\n\n\nsuperuser\n\n\nTrue\n if the role should be given superuser privileges (defaults to \nFalse\n).\n\n\n\n\npassword\n\n\nPlaintext password to set for this role (will be hashed using MD5).\n\n\nPlease do not write any passwords into your bundles. This attribute is intended to be used with an external source of passwords and filled dynamically. If you don't have or want such an elaborate setup, specify passwords using the \npassword_hash\n attribute instead.\n\n\n\n\n\npassword_hash\n\n\nAs an alternative to \npassword\n, this allows setting the raw hash as it will be stored in Postgres' internal database. Should start with \"md5\".",
            "title": "postgres_role"
        },
        {
            "location": "/items/postgres_role/#postgres-role-items",
            "text": "Manages Postgres roles.  postgres_roles = {\n    \"me\": {\n        \"superuser\": True,\n        \"password\": \"itsamemario\",\n    },\n}",
            "title": "Postgres role items"
        },
        {
            "location": "/items/postgres_role/#attribute-reference",
            "text": "See also:  The list of generic builtin item attributes",
            "title": "Attribute reference"
        },
        {
            "location": "/items/postgres_role/#superuser",
            "text": "True  if the role should be given superuser privileges (defaults to  False ).",
            "title": "superuser"
        },
        {
            "location": "/items/postgres_role/#password",
            "text": "Plaintext password to set for this role (will be hashed using MD5).  Please do not write any passwords into your bundles. This attribute is intended to be used with an external source of passwords and filled dynamically. If you don't have or want such an elaborate setup, specify passwords using the  password_hash  attribute instead.",
            "title": "password"
        },
        {
            "location": "/items/postgres_role/#password_hash",
            "text": "As an alternative to  password , this allows setting the raw hash as it will be stored in Postgres' internal database. Should start with \"md5\".",
            "title": "password_hash"
        },
        {
            "location": "/items/svc_openbsd/",
            "text": "OpenBSD service items\n\n\nHandles services on OpenBSD.\n\n\nsvc_openbsd = {\n    \"bgpd\": {\n        \"enabled\": True, # default\n        \"running\": True,  # default\n    },\n    \"supervisord\": {\n        \"running\": False,\n    },\n}\n\n\n\n\n\nAttribute reference\n\n\nSee also: \nThe list of generic builtin item attributes\n\n\n\n\nenabled\n\n\nTrue\n if the service shall be automatically started during system bootup; \nFalse\n otherwise. \nTrue\n, the default value, is needed on OpenBSD, as starting disabled services fails.\n\n\n\n\nrunning\n\n\nTrue\n if the service is expected to be running on the system; \nFalse\n if it should be stopped.\n\n\n\n\nCanned actions\n\n\nSee also: \nExplanation of how canned actions work\n\n\nrestart\n\n\nRestarts the service.\n\n\n\n\nstopstart\n\n\nStops and starts the service.",
            "title": "svc_openbsd"
        },
        {
            "location": "/items/svc_openbsd/#openbsd-service-items",
            "text": "Handles services on OpenBSD.  svc_openbsd = {\n    \"bgpd\": {\n        \"enabled\": True, # default\n        \"running\": True,  # default\n    },\n    \"supervisord\": {\n        \"running\": False,\n    },\n}",
            "title": "OpenBSD service items"
        },
        {
            "location": "/items/svc_openbsd/#attribute-reference",
            "text": "See also:  The list of generic builtin item attributes",
            "title": "Attribute reference"
        },
        {
            "location": "/items/svc_openbsd/#enabled",
            "text": "True  if the service shall be automatically started during system bootup;  False  otherwise.  True , the default value, is needed on OpenBSD, as starting disabled services fails.",
            "title": "enabled"
        },
        {
            "location": "/items/svc_openbsd/#running",
            "text": "True  if the service is expected to be running on the system;  False  if it should be stopped.",
            "title": "running"
        },
        {
            "location": "/items/svc_openbsd/#canned-actions",
            "text": "See also:  Explanation of how canned actions work",
            "title": "Canned actions"
        },
        {
            "location": "/items/svc_openbsd/#restart",
            "text": "Restarts the service.",
            "title": "restart"
        },
        {
            "location": "/items/svc_openbsd/#stopstart",
            "text": "Stops and starts the service.",
            "title": "stopstart"
        },
        {
            "location": "/items/svc_systemd/",
            "text": "systemd service items\n\n\nHandles services managed by systemd.\n\n\nsvc_systemd = {\n    \"fcron.service\": {\n        \"enabled\": True,  # default\n        \"running\": True,  # default\n    },\n    \"sgopherd.socket\": {\n        \"running\": False,\n    },\n}\n\n\n\n\n\nAttribute reference\n\n\nSee also: \nThe list of generic builtin item attributes\n\n\n\n\nenabled\n\n\nTrue\n if the service shall be automatically started during system bootup; \nFalse\n otherwise. \nNone\n makes BundleWrap ignore this setting.\n\n\n\n\nrunning\n\n\nTrue\n if the service is expected to be running on the system; \nFalse\n if it should be stopped. \nNone\n makes BundleWrap ignore this setting.\n\n\n\n\nCanned actions\n\n\nSee also: \nExplanation of how canned actions work\n\n\nreload\n\n\nReloads the service.\n\n\n\n\nrestart\n\n\nRestarts the service.",
            "title": "svc_systemd"
        },
        {
            "location": "/items/svc_systemd/#systemd-service-items",
            "text": "Handles services managed by systemd.  svc_systemd = {\n    \"fcron.service\": {\n        \"enabled\": True,  # default\n        \"running\": True,  # default\n    },\n    \"sgopherd.socket\": {\n        \"running\": False,\n    },\n}",
            "title": "systemd service items"
        },
        {
            "location": "/items/svc_systemd/#attribute-reference",
            "text": "See also:  The list of generic builtin item attributes",
            "title": "Attribute reference"
        },
        {
            "location": "/items/svc_systemd/#enabled",
            "text": "True  if the service shall be automatically started during system bootup;  False  otherwise.  None  makes BundleWrap ignore this setting.",
            "title": "enabled"
        },
        {
            "location": "/items/svc_systemd/#running",
            "text": "True  if the service is expected to be running on the system;  False  if it should be stopped.  None  makes BundleWrap ignore this setting.",
            "title": "running"
        },
        {
            "location": "/items/svc_systemd/#canned-actions",
            "text": "See also:  Explanation of how canned actions work",
            "title": "Canned actions"
        },
        {
            "location": "/items/svc_systemd/#reload",
            "text": "Reloads the service.",
            "title": "reload"
        },
        {
            "location": "/items/svc_systemd/#restart",
            "text": "Restarts the service.",
            "title": "restart"
        },
        {
            "location": "/items/svc_systemv/",
            "text": "System V service items\n\n\nHandles services managed by traditional System V init scripts.\n\n\nsvc_systemv = {\n    \"apache2\": {\n        \"running\": True,  # default\n    },\n    \"mysql\": {\n        \"running\": False,\n    },\n}\n\n\n\n\n\nAttribute reference\n\n\nSee also: \nThe list of generic builtin item attributes\n\n\n\n\nrunning\n\n\nTrue\n if the service is expected to be running on the system; \nFalse\n if it should be stopped.\n\n\n\n\nCanned actions\n\n\nSee also: \nExplanation of how canned actions work\n\n\nreload\n\n\nReloads the service.\n\n\n\n\nrestart\n\n\nRestarts the service.",
            "title": "svc_systemv"
        },
        {
            "location": "/items/svc_systemv/#system-v-service-items",
            "text": "Handles services managed by traditional System V init scripts.  svc_systemv = {\n    \"apache2\": {\n        \"running\": True,  # default\n    },\n    \"mysql\": {\n        \"running\": False,\n    },\n}",
            "title": "System V service items"
        },
        {
            "location": "/items/svc_systemv/#attribute-reference",
            "text": "See also:  The list of generic builtin item attributes",
            "title": "Attribute reference"
        },
        {
            "location": "/items/svc_systemv/#running",
            "text": "True  if the service is expected to be running on the system;  False  if it should be stopped.",
            "title": "running"
        },
        {
            "location": "/items/svc_systemv/#canned-actions",
            "text": "See also:  Explanation of how canned actions work",
            "title": "Canned actions"
        },
        {
            "location": "/items/svc_systemv/#reload",
            "text": "Reloads the service.",
            "title": "reload"
        },
        {
            "location": "/items/svc_systemv/#restart",
            "text": "Restarts the service.",
            "title": "restart"
        },
        {
            "location": "/items/svc_upstart/",
            "text": "Upstart service items\n\n\nHandles services managed by Upstart.\n\n\nsvc_upstart = {\n    \"gunicorn\": {\n        \"running\": True,  # default\n    },\n    \"celery\": {\n        \"running\": False,\n    },\n}\n\n\n\n\n\nAttribute reference\n\n\nSee also: \nThe list of generic builtin item attributes\n\n\n\n\nrunning\n\n\nTrue\n if the service is expected to be running on the system; \nFalse\n if it should be stopped.\n\n\n\n\nCanned actions\n\n\nSee also: \nExplanation of how canned actions work\n\n\nreload\n\n\nReloads the service.\n\n\n\n\nrestart\n\n\nRestarts the service.\n\n\n\n\nstopstart\n\n\nStops and then starts the service. This is different from \nrestart\n in that Upstart will pick up changes to the \n/etc/init/SERVICENAME.conf\n file, while \nrestart\n will continue to use the version of that file that the service was originally started with. See \nhttp://askubuntu.com/a/238069\n.",
            "title": "svc_upstart"
        },
        {
            "location": "/items/svc_upstart/#upstart-service-items",
            "text": "Handles services managed by Upstart.  svc_upstart = {\n    \"gunicorn\": {\n        \"running\": True,  # default\n    },\n    \"celery\": {\n        \"running\": False,\n    },\n}",
            "title": "Upstart service items"
        },
        {
            "location": "/items/svc_upstart/#attribute-reference",
            "text": "See also:  The list of generic builtin item attributes",
            "title": "Attribute reference"
        },
        {
            "location": "/items/svc_upstart/#running",
            "text": "True  if the service is expected to be running on the system;  False  if it should be stopped.",
            "title": "running"
        },
        {
            "location": "/items/svc_upstart/#canned-actions",
            "text": "See also:  Explanation of how canned actions work",
            "title": "Canned actions"
        },
        {
            "location": "/items/svc_upstart/#reload",
            "text": "Reloads the service.",
            "title": "reload"
        },
        {
            "location": "/items/svc_upstart/#restart",
            "text": "Restarts the service.",
            "title": "restart"
        },
        {
            "location": "/items/svc_upstart/#stopstart",
            "text": "Stops and then starts the service. This is different from  restart  in that Upstart will pick up changes to the  /etc/init/SERVICENAME.conf  file, while  restart  will continue to use the version of that file that the service was originally started with. See  http://askubuntu.com/a/238069 .",
            "title": "stopstart"
        },
        {
            "location": "/items/symlink/",
            "text": "Symlink items\n\n\nsymlinks = {\n    \"/some/symlink\": {\n        \"group\": \"root\",\n        \"owner\": \"root\",\n        \"target\": \"/target/file\",\n    },\n}\n\n\n\n\n\nAttribute reference\n\n\nSee also: \nThe list of generic builtin item attributes\n\n\n\n\ntarget\n\n\nFile or directory this symlink points to. \nThis attribute is required.\n\n\n\n\ngroup\n\n\nName of the group this symlink belongs to. Defaults to \n'root'\n. Set to \nNone\n if you don't want BundleWrap to change whatever is set on the node.\n\n\n\n\nowner\n\n\nUsername of the symlink's owner. Defaults to \n'root'\n. Set to \nNone\n if you don't want BundleWrap to change whatever is set on the node.",
            "title": "symlink"
        },
        {
            "location": "/items/symlink/#symlink-items",
            "text": "symlinks = {\n    \"/some/symlink\": {\n        \"group\": \"root\",\n        \"owner\": \"root\",\n        \"target\": \"/target/file\",\n    },\n}",
            "title": "Symlink items"
        },
        {
            "location": "/items/symlink/#attribute-reference",
            "text": "See also:  The list of generic builtin item attributes",
            "title": "Attribute reference"
        },
        {
            "location": "/items/symlink/#target",
            "text": "File or directory this symlink points to.  This attribute is required.",
            "title": "target"
        },
        {
            "location": "/items/symlink/#group",
            "text": "Name of the group this symlink belongs to. Defaults to  'root' . Set to  None  if you don't want BundleWrap to change whatever is set on the node.",
            "title": "group"
        },
        {
            "location": "/items/symlink/#owner",
            "text": "Username of the symlink's owner. Defaults to  'root' . Set to  None  if you don't want BundleWrap to change whatever is set on the node.",
            "title": "owner"
        },
        {
            "location": "/items/user/",
            "text": "User items\n\n\nManages system user accounts.\n\n\nusers = {\n    \"jdoe\": {\n        \"full_name\": \"Jane Doe\",\n        \"gid\": 2342,\n        \"groups\": [\"admins\", \"users\", \"wheel\"],\n        \"home\": \"/home/jdoe\",\n        \"password_hash\": \"$6$abcdef$ghijklmnopqrstuvwxyz\",\n        \"shell\": \"/bin/zsh\",\n        \"uid\": 4747,\n    },\n}\n\n\n\n\n\nAttribute reference\n\n\nSee also: \nThe list of generic builtin item attributes\n\n\nAll attributes are optional.\n\n\n\n\ndelete\n\n\nWhen set to \nTrue\n, this user will be removed from the system. Note that because of how \nuserdel\n works, the primary group of the user will be removed if it contains no other users. When using \ndelete\n, no other attributes are allowed.\n\n\n\n\nfull_name\n\n\nFull name of the user.\n\n\n\n\ngid\n\n\nPrimary group of the user as numerical ID or group name.\n\n\nDue to how \nuseradd\n works, this attribute is required whenever you \ndon't\n want the default behavior of \nuseradd\n (usually that means automatically creating a group with the same name as the user). If you want to use an unmanaged group already on the node, you need this attribute. If you want to use a group managed by BundleWrap, you need this attribute. This is true even if the groups mentioned are in fact named like the user.\n\n\n\n\n\ngroups\n\n\nList of groups (names, not GIDs) the user should belong to. Must NOT include the group referenced by \ngid\n.\n\n\n\n\nhash_method\n\n\nOne of:\n\n\n\n\nmd5\n\n\nsha256\n\n\nsha512\n\n\n\n\nDefaults to \nsha512\n.\n\n\n\n\nhome\n\n\nPath to home directory. Defaults to \n/home/USERNAME\n.\n\n\n\n\npassword\n\n\nThe user's password in plaintext.\n\n\nPlease do not write any passwords into your bundles. This attribute is intended to be used with an external source of passwords and filled dynamically. If you don't have or want such an elaborate setup, specify passwords using the \npassword_hash\n attribute instead.\n\n\n\nIf you don't specify a \nsalt\n along with the password, BundleWrap will use a static salt. Be aware that this is basically the same as using no salt at all.\n\n\n\n\n\npassword_hash\n\n\nHashed password as it would be returned by \ncrypt()\n and written to \n/etc/shadow\n.\n\n\n\n\nsalt\n\n\nRecommended for use with the \npassword\n attribute. BundleWrap will use 5000 rounds of SHA-512 on this salt and the provided password.\n\n\n\n\nshell\n\n\nPath to login shell executable.\n\n\n\n\nuid\n\n\nNumerical user ID. It's your job to make sure it's unique.",
            "title": "user"
        },
        {
            "location": "/items/user/#user-items",
            "text": "Manages system user accounts.  users = {\n    \"jdoe\": {\n        \"full_name\": \"Jane Doe\",\n        \"gid\": 2342,\n        \"groups\": [\"admins\", \"users\", \"wheel\"],\n        \"home\": \"/home/jdoe\",\n        \"password_hash\": \"$6$abcdef$ghijklmnopqrstuvwxyz\",\n        \"shell\": \"/bin/zsh\",\n        \"uid\": 4747,\n    },\n}",
            "title": "User items"
        },
        {
            "location": "/items/user/#attribute-reference",
            "text": "See also:  The list of generic builtin item attributes  All attributes are optional.",
            "title": "Attribute reference"
        },
        {
            "location": "/items/user/#delete",
            "text": "When set to  True , this user will be removed from the system. Note that because of how  userdel  works, the primary group of the user will be removed if it contains no other users. When using  delete , no other attributes are allowed.",
            "title": "delete"
        },
        {
            "location": "/items/user/#full_name",
            "text": "Full name of the user.",
            "title": "full_name"
        },
        {
            "location": "/items/user/#gid",
            "text": "Primary group of the user as numerical ID or group name.  Due to how  useradd  works, this attribute is required whenever you  don't  want the default behavior of  useradd  (usually that means automatically creating a group with the same name as the user). If you want to use an unmanaged group already on the node, you need this attribute. If you want to use a group managed by BundleWrap, you need this attribute. This is true even if the groups mentioned are in fact named like the user.",
            "title": "gid"
        },
        {
            "location": "/items/user/#groups",
            "text": "List of groups (names, not GIDs) the user should belong to. Must NOT include the group referenced by  gid .",
            "title": "groups"
        },
        {
            "location": "/items/user/#hash_method",
            "text": "One of:   md5  sha256  sha512   Defaults to  sha512 .",
            "title": "hash_method"
        },
        {
            "location": "/items/user/#home",
            "text": "Path to home directory. Defaults to  /home/USERNAME .",
            "title": "home"
        },
        {
            "location": "/items/user/#password",
            "text": "The user's password in plaintext.  Please do not write any passwords into your bundles. This attribute is intended to be used with an external source of passwords and filled dynamically. If you don't have or want such an elaborate setup, specify passwords using the  password_hash  attribute instead.  If you don't specify a  salt  along with the password, BundleWrap will use a static salt. Be aware that this is basically the same as using no salt at all.",
            "title": "password"
        },
        {
            "location": "/items/user/#password_hash",
            "text": "Hashed password as it would be returned by  crypt()  and written to  /etc/shadow .",
            "title": "password_hash"
        },
        {
            "location": "/items/user/#salt",
            "text": "Recommended for use with the  password  attribute. BundleWrap will use 5000 rounds of SHA-512 on this salt and the provided password.",
            "title": "salt"
        },
        {
            "location": "/items/user/#shell",
            "text": "Path to login shell executable.",
            "title": "shell"
        },
        {
            "location": "/items/user/#uid",
            "text": "Numerical user ID. It's your job to make sure it's unique.",
            "title": "uid"
        },
        {
            "location": "/misc/about/",
            "text": ".bs-sidebar { display: none; }\n\n\n\nAbout\n\n\nDevelopment on BundleWrap started in July 2012, borrowing some ideas from \nBcfg2\n. Some key features that are meant to set BundleWrap apart from other config management systems are:\n\n\n\n\ndecentralized architecture\n\n\npythonic and easily extendable\n\n\neasy to get started with\n\n\ntrue item-level parallelism (in addition to working on multiple nodes simultaneously, BundleWrap will continue to fix config files while installing a package on the same node)\n\n\nvery customizable item dependencies\n\n\ncollaboration features like \nnode locking\n (to prevent simultaneous applies to the same node) and hooks for chat notifications\n\n\nbuilt-in testing facility (\nbw test\n)\n\n\ncan be used as a library\n\n\n\n\nBundleWrap is a \"pure\" free software project licensed under the terms of the \nGPLv3\n, with no \nEnterprise Edition\n or commercial support.",
            "title": "About"
        },
        {
            "location": "/misc/about/#about",
            "text": "Development on BundleWrap started in July 2012, borrowing some ideas from  Bcfg2 . Some key features that are meant to set BundleWrap apart from other config management systems are:   decentralized architecture  pythonic and easily extendable  easy to get started with  true item-level parallelism (in addition to working on multiple nodes simultaneously, BundleWrap will continue to fix config files while installing a package on the same node)  very customizable item dependencies  collaboration features like  node locking  (to prevent simultaneous applies to the same node) and hooks for chat notifications  built-in testing facility ( bw test )  can be used as a library   BundleWrap is a \"pure\" free software project licensed under the terms of the  GPLv3 , with no  Enterprise Edition  or commercial support.",
            "title": "About"
        },
        {
            "location": "/misc/glossary/",
            "text": "Glossary\n\n\naction\n\n\nActions are a special kind of item used for running shell commands during each \nbw apply\n. They allow you to do things that aren't persistent in nature.\n\n\n\n\napply\n\n\nAn \"apply\" is what we call the process of what's otherwise known as \"converging\" the state described by your repository and the actual status quo on the node.\n\n\n\n\nbundle\n\n\nA collection of items. Most of the time, you will create one bundle per application. For example, an Apache bundle will include the httpd service, the virtual host definitions and the apache2 package.\n\n\n\n\ngroup\n\n\nUsed for organizing your nodes.\n\n\n\n\nhook\n\n\nHooks\n can be used to run your own code automatically during various stages of BundleWrap operations.\n\n\n\n\nitem\n\n\nA single piece of configuration on a node, e.g. a file or an installed package.\n\n\nYou might be interested in \nthis overview of item types\n.\n\n\n\n\nlib\n\n\nLibs\n are a way to store Python modules in your repository and make them accessible to your bundles and templates.\n\n\n\n\nnode\n\n\nA managed system, no matter if physical or virtual.\n\n\n\n\nrepo\n\n\nA repository is a directory with \nsome stuff\n in it that tells BundleWrap everything it needs to know about your infrastructure.",
            "title": "Glossary"
        },
        {
            "location": "/misc/glossary/#glossary",
            "text": "",
            "title": "Glossary"
        },
        {
            "location": "/misc/glossary/#action",
            "text": "Actions are a special kind of item used for running shell commands during each  bw apply . They allow you to do things that aren't persistent in nature.",
            "title": "action"
        },
        {
            "location": "/misc/glossary/#apply",
            "text": "An \"apply\" is what we call the process of what's otherwise known as \"converging\" the state described by your repository and the actual status quo on the node.",
            "title": "apply"
        },
        {
            "location": "/misc/glossary/#bundle",
            "text": "A collection of items. Most of the time, you will create one bundle per application. For example, an Apache bundle will include the httpd service, the virtual host definitions and the apache2 package.",
            "title": "bundle"
        },
        {
            "location": "/misc/glossary/#group",
            "text": "Used for organizing your nodes.",
            "title": "group"
        },
        {
            "location": "/misc/glossary/#hook",
            "text": "Hooks  can be used to run your own code automatically during various stages of BundleWrap operations.",
            "title": "hook"
        },
        {
            "location": "/misc/glossary/#item",
            "text": "A single piece of configuration on a node, e.g. a file or an installed package.  You might be interested in  this overview of item types .",
            "title": "item"
        },
        {
            "location": "/misc/glossary/#lib",
            "text": "Libs  are a way to store Python modules in your repository and make them accessible to your bundles and templates.",
            "title": "lib"
        },
        {
            "location": "/misc/glossary/#node",
            "text": "A managed system, no matter if physical or virtual.",
            "title": "node"
        },
        {
            "location": "/misc/glossary/#repo",
            "text": "A repository is a directory with  some stuff  in it that tells BundleWrap everything it needs to know about your infrastructure.",
            "title": "repo"
        },
        {
            "location": "/misc/faq/",
            "text": "FAQ\n\n\nTechnical\n\n\nBundleWrap says an item failed to apply, what do I do now?\n\n\nTry running \nbw apply -i nodename\n to see which attribute of the item could not be fixed. If that doesn't tell you enough, try \nbw --debug apply -i nodename\n and look for the command BundleWrap is using to fix the item in question. Then try running that command yourself and check for any errors.\n\n\n\n\nWhat happens when two people start applying configuration to the same node?\n\n\nBundleWrap uses a \nlocking mechanism\n to prevent collisions like this.\n\n\n\n\nHow can I have BundleWrap reload my services after config changes?\n\n\nSee \ncanned actions\n and \ntriggers\n.\n\n\n\n\nWill BundleWrap keep track of package updates?\n\n\nNo. BundleWrap will only care about whether a package is installed or not. Updates will have to be installed through a separate mechanism (I like to create an \naction\n with the \ninteractive\n attribute set to \nTrue\n). Selecting specific versions should be done through your package manager.\n\n\n\n\nIs there a probing mechanism like Ohai?\n\n\nNo. BundleWrap is meant to be very push-focused. The node should not have any say in what configuration it will receive.\n\n\n\n\nIs BundleWrap secure?\n\n\nBundleWrap is more concerned with safety than security. Due to its design, it is possible for your coworkers to introduce malicious code into a BundleWrap repository that could compromise your machine. You should only use trusted repositories and plugins. We also recommend following commit logs to your repos.\n\n\n\n\nThe BundleWrap Project\n\n\nWhy doesn't BundleWrap provide pre-built community bundles?\n\n\nIn our experience, bundles for even the most common pieces of software always contain some opinionated bits specific to local infrastructure. Making bundles truly universal (e.g. in terms of supported Linux distributions) would mean a lot of bloat. And since local modifications are hard to reconcile with an upstream community repository, bundles would have to be very feature-complete to be useful to the majority of users, increasing bloat even more.\n\n\nMaintaining bundles and thus configuration for different pieces of software is therefore out of scope for the BundleWrap project. While it might seem tedious when you're getting started, with some practice, writing your own bundles will become both easy and precise in terms of infrastructure fit.\n\n\n\n\nWhy do contributors have to sign a Copyright Assignment Agreement?\n\n\nWhile it sounds scary, Copyright assignment is used to improve the enforceability of the GPL. Even the FSF does it, \nread their explanation why\n. The agreement used by BundleWrap is from \nharmonyagreements.org\n.\n\n\nIf you're still concerned, please do not hesitate to contact \n@trehn\n.",
            "title": "FAQ"
        },
        {
            "location": "/misc/faq/#faq",
            "text": "",
            "title": "FAQ"
        },
        {
            "location": "/misc/faq/#technical",
            "text": "",
            "title": "Technical"
        },
        {
            "location": "/misc/faq/#bundlewrap-says-an-item-failed-to-apply-what-do-i-do-now",
            "text": "Try running  bw apply -i nodename  to see which attribute of the item could not be fixed. If that doesn't tell you enough, try  bw --debug apply -i nodename  and look for the command BundleWrap is using to fix the item in question. Then try running that command yourself and check for any errors.",
            "title": "BundleWrap says an item failed to apply, what do I do now?"
        },
        {
            "location": "/misc/faq/#what-happens-when-two-people-start-applying-configuration-to-the-same-node",
            "text": "BundleWrap uses a  locking mechanism  to prevent collisions like this.",
            "title": "What happens when two people start applying configuration to the same node?"
        },
        {
            "location": "/misc/faq/#how-can-i-have-bundlewrap-reload-my-services-after-config-changes",
            "text": "See  canned actions  and  triggers .",
            "title": "How can I have BundleWrap reload my services after config changes?"
        },
        {
            "location": "/misc/faq/#will-bundlewrap-keep-track-of-package-updates",
            "text": "No. BundleWrap will only care about whether a package is installed or not. Updates will have to be installed through a separate mechanism (I like to create an  action  with the  interactive  attribute set to  True ). Selecting specific versions should be done through your package manager.",
            "title": "Will BundleWrap keep track of package updates?"
        },
        {
            "location": "/misc/faq/#is-there-a-probing-mechanism-like-ohai",
            "text": "No. BundleWrap is meant to be very push-focused. The node should not have any say in what configuration it will receive.",
            "title": "Is there a probing mechanism like Ohai?"
        },
        {
            "location": "/misc/faq/#is-bundlewrap-secure",
            "text": "BundleWrap is more concerned with safety than security. Due to its design, it is possible for your coworkers to introduce malicious code into a BundleWrap repository that could compromise your machine. You should only use trusted repositories and plugins. We also recommend following commit logs to your repos.",
            "title": "Is BundleWrap secure?"
        },
        {
            "location": "/misc/faq/#the-bundlewrap-project",
            "text": "",
            "title": "The BundleWrap Project"
        },
        {
            "location": "/misc/faq/#why-doesnt-bundlewrap-provide-pre-built-community-bundles",
            "text": "In our experience, bundles for even the most common pieces of software always contain some opinionated bits specific to local infrastructure. Making bundles truly universal (e.g. in terms of supported Linux distributions) would mean a lot of bloat. And since local modifications are hard to reconcile with an upstream community repository, bundles would have to be very feature-complete to be useful to the majority of users, increasing bloat even more.  Maintaining bundles and thus configuration for different pieces of software is therefore out of scope for the BundleWrap project. While it might seem tedious when you're getting started, with some practice, writing your own bundles will become both easy and precise in terms of infrastructure fit.",
            "title": "Why doesn't BundleWrap provide pre-built community bundles?"
        },
        {
            "location": "/misc/faq/#why-do-contributors-have-to-sign-a-copyright-assignment-agreement",
            "text": "While it sounds scary, Copyright assignment is used to improve the enforceability of the GPL. Even the FSF does it,  read their explanation why . The agreement used by BundleWrap is from  harmonyagreements.org .  If you're still concerned, please do not hesitate to contact  @trehn .",
            "title": "Why do contributors have to sign a Copyright Assignment Agreement?"
        },
        {
            "location": "/misc/contributing/",
            "text": "Contributing\n\n\nWe welcome all input and contributions to BundleWrap. If you've never done this sort of thing before, maybe check out \ncontribution-guide.org\n. But don't be afraid to make mistakes, nobody expects your first contribution to be perfect. We'll gladly help you out.\n\n\n\n\nSubmitting bug reports\n\n\nPlease use the \nGitHub issue tracker\n and take a few minutes to look for existing reports of the same problem (open or closed!).\n\n\nIf you've found a security issue or are not at all sure, just contact \ntrehn@bundlewrap.org\n.\n\n\n\n\n\nContributing code\n\n\nBefore working on new features, try reaching out to one of the core authors first. We are very concerned with keeping BundleWrap lean and not introducing bloat. If your idea is not a good fit for all or most BundleWrap users, it can still be included \nas a plugin\n.\n\n\n\nHere are the steps:\n\n\n\n\nWrite your code. Awesome!\n\n\nIf you haven't already done so, please consider writing tests. Otherwise, someone else will have to do it for you.\n\n\nSame goes for documentation.\n\n\nSet up a \nvirtualenv\n and run \npip install -r requirements.txt\n.\n\n\nMake sure you can connect to your localhost via \nssh\n without using a password and that you are able to run \nsudo\n.\n\n\nRun \ntox\n.\n\n\nReview and sign the Copyright Assignment Agreement (CAA) by adding your name and email to the \nAUTHORS\n file. (This step can be skipped if your contribution is too small to be considered intellectual property, e.g. spelling fixes)\n\n\nOpen a pull request on \nGitHub\n.\n\n\nFeel great. Thank you.\n\n\n\n\n\n\nContributing documentation\n\n\nThe process is essentially the same as detailed above for code contributions. You will find the docs in \ndocs/content/\n and can preview them using \ncd docs && mkdocs serve\n.\n\n\n\n\nHelp\n\n\nIf at any point you need help or are not sure what to do, just drop by in \n#bundlewrap on Freenode\n or poke \n@bundlewrap on Twitter\n.",
            "title": "Contributing"
        },
        {
            "location": "/misc/contributing/#contributing",
            "text": "We welcome all input and contributions to BundleWrap. If you've never done this sort of thing before, maybe check out  contribution-guide.org . But don't be afraid to make mistakes, nobody expects your first contribution to be perfect. We'll gladly help you out.",
            "title": "Contributing"
        },
        {
            "location": "/misc/contributing/#submitting-bug-reports",
            "text": "Please use the  GitHub issue tracker  and take a few minutes to look for existing reports of the same problem (open or closed!).  If you've found a security issue or are not at all sure, just contact  trehn@bundlewrap.org .",
            "title": "Submitting bug reports"
        },
        {
            "location": "/misc/contributing/#contributing-code",
            "text": "Before working on new features, try reaching out to one of the core authors first. We are very concerned with keeping BundleWrap lean and not introducing bloat. If your idea is not a good fit for all or most BundleWrap users, it can still be included  as a plugin .  Here are the steps:   Write your code. Awesome!  If you haven't already done so, please consider writing tests. Otherwise, someone else will have to do it for you.  Same goes for documentation.  Set up a  virtualenv  and run  pip install -r requirements.txt .  Make sure you can connect to your localhost via  ssh  without using a password and that you are able to run  sudo .  Run  tox .  Review and sign the Copyright Assignment Agreement (CAA) by adding your name and email to the  AUTHORS  file. (This step can be skipped if your contribution is too small to be considered intellectual property, e.g. spelling fixes)  Open a pull request on  GitHub .  Feel great. Thank you.",
            "title": "Contributing code"
        },
        {
            "location": "/misc/contributing/#contributing-documentation",
            "text": "The process is essentially the same as detailed above for code contributions. You will find the docs in  docs/content/  and can preview them using  cd docs && mkdocs serve .",
            "title": "Contributing documentation"
        },
        {
            "location": "/misc/contributing/#help",
            "text": "If at any point you need help or are not sure what to do, just drop by in  #bundlewrap on Freenode  or poke  @bundlewrap on Twitter .",
            "title": "Help"
        }
    ]
}